<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHB-CSDN</title>
  
  <subtitle>Be here now</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang-hongbin.github.io/"/>
  <updated>2018-04-17T03:06:35.328Z</updated>
  <id>https://zhang-hongbin.github.io/</id>
  
  <author>
    <name>Zhang Hongbin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5. React 样式</title>
    <link href="https://zhang-hongbin.github.io/2018/02/10/React%20%E6%A0%B7%E5%BC%8F/"/>
    <id>https://zhang-hongbin.github.io/2018/02/10/React 样式/</id>
    <published>2018-02-10T07:06:46.000Z</published>
    <updated>2018-04-17T03:06:35.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、内联样式"><a href="#一、内联样式" class="headerlink" title="一、内联样式"></a>一、内联样式</h2><ol><li>CSS命名规范:dialog_confirm–button–highlight</li><li>注意样式的驼峰写法</li><li><p>第一种引用形式<br>在<code>head.js</code>文件修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line"><span class="comment">//添加componengtHeadStyle部分,注意是在render函数内部</span></span><br><span class="line">        <span class="keyword">const</span> componentHeadStyle = &#123;</span><br><span class="line">            header : &#123;</span><br><span class="line">                backgroundColor:<span class="string">"#333333"</span>,</span><br><span class="line">                color:<span class="string">"#FFFFFF"</span>,</span><br><span class="line">                paddingTop:<span class="string">"15px"</span>,</span><br><span class="line">                paddingBottom:<span class="string">'15px'</span></span><br><span class="line">            &#125; ,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"><span class="comment">//样式引入</span></span><br><span class="line">            &lt;header style = &#123; componentHeadStyle.header &#125; &gt;</span><br><span class="line">                &lt;h2&gt;这是首部&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>header&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种引入形式——文件中引用css的形式</p><div style="margin-left:30px"></div></li></ol><p>(1) 创建<code>/js/css/style.css</code>文件，其代码为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.smallFontSize</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2) 样式引入<br>在<code>index.html</code>文件中添加<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./src/css/style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>在<code>header.js</code>文件中添加<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;header style=&#123;componentHeadStyle.header&#125; className=<span class="string">"smallFontSize"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>注意<code>class</code>需要更改为<code>className</code><br></p><ol start="5"><li>缺点是动画、伪类{hover}等不能使用</li></ol><hr><h2 id="二、内联样式中的表达式"><a href="#二、内联样式中的表达式" class="headerlink" title="二、内联样式中的表达式"></a>二、内联样式中的表达式</h2><ol><li><code>paddingBottom:(this.state.miniHeader)?&#39;3px&#39;:&#39;15px&#39;</code></li><li>注意好好理解这里的<code>state</code>引起样式的即时变化</li></ol><hr><h2 id="三、CSS模块化"><a href="#三、CSS模块化" class="headerlink" title="三、CSS模块化"></a>三、CSS模块化</h2><p>本节需要安装<code>babel-plugin-react-html-attrs</code> <code>style-loader</code> <code>css-loader</code>三个插件，具体代码如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install babel-plugin-react-html-attrs style-loader css-loader --save-dev</span><br></pre></td></tr></table></figure></p><p>以下为本章具体知识结构：</p><ul><li>CSS模块化：1.全局污染 2.命名混乱 3.依赖管理不彻底 4.无法共享变量 5.代码压缩不彻底</li><li>CSS Modules模块化<center><img src="http://oo590vn4k.bkt.clouddn.com/20180210-1.png"></center></li><li>babel-plugin-react-html-attrs <a href="https://github.com/insin/babel-plugin-react-html-attrs" target="_blank" rel="noopener">https://github.com/insin/babel-plugin-react-html-attrs</a></li><li>style-loader <a href="https://github.com/webpack/style-loader" target="_blank" rel="noopener">https://github.com/webpack/style-loader</a></li><li>css-loader <a href="https://github.com/webpack/css-loader" target="_blank" rel="noopener">https://github.com/webpack/css-loader</a></li><li>导入：var footerCss = require(“../../css/footer/css”);</li><li>使用：<footer class="{footerCss.miniFooter}"></footer></li><li>:local(.normal){color:green;}</li><li>:global(.btn){color:red;}</li><li>CSS模块化优点：1.所有模块都是local的，解决了命名冲突和全局污染问题 2.class名生成规则配置灵活，可以用来压缩class名 3.只需引用组件的JS就能搞定组件所有的JS和CSS 4.依然是CSS，几乎零学习成本</li></ul><hr><h2 id="四、JSX样式与CSS的互转"><a href="#四、JSX样式与CSS的互转" class="headerlink" title="四、JSX样式与CSS的互转"></a>四、JSX样式与CSS的互转</h2><p>在线转换工具：<a href="https://staxmanade.com/CssToReact/" target="_blank" rel="noopener">https://staxmanade.com/CssToReact/</a></p><hr><h2 id="五、Ant-Design样式框架介绍"><a href="#五、Ant-Design样式框架介绍" class="headerlink" title="五、Ant Design样式框架介绍"></a>五、Ant Design样式框架介绍</h2><ol><li>谷歌团队开发的material框架 <a href="http://www.material-ui.com/" target="_blank" rel="noopener">http://www.material-ui.com/</a></li><li>蚂蚁金服开发的框架 <a href="http://ant.design/" target="_blank" rel="noopener">http://ant.design/</a></li></ol><hr><h2 id="六、Ant-Design样式框架使用"><a href="#六、Ant-Design样式框架使用" class="headerlink" title="六、Ant Design样式框架使用"></a>六、Ant Design样式框架使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Input&#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br></pre></td></tr></table></figure><p>antd可以惰性加载。 样式见框架官网。<br>具体内容将在之后说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、内联样式&quot;&gt;&lt;a href=&quot;#一、内联样式&quot; class=&quot;headerlink&quot; title=&quot;一、内联样式&quot;&gt;&lt;/a&gt;一、内联样式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CSS命名规范:dialog_confirm–button–highlight&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>4. React 属性与事件</title>
    <link href="https://zhang-hongbin.github.io/2018/01/10/React%20%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6/"/>
    <id>https://zhang-hongbin.github.io/2018/01/10/React 属性与事件/</id>
    <published>2018-01-10T07:06:46.000Z</published>
    <updated>2018-04-15T14:08:29.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-State-属性"><a href="#1-State-属性" class="headerlink" title="1. State 属性"></a>1. State 属性</h2><center><img src="http://oo590vn4k.bkt.clouddn.com/2018011001.png"></center><p>State 属性：</p><ol><li><code>state</code> 对于模块属于自身属性</li><li>初始化: <pre><code>this.state = {username:&quot;Parry&quot;};</code></pre></li><li>初始化可以放置在构造函数 <code>constructor</code> 里</li><li>修改 <code>state</code>: <pre><code>this.setState{{username:"IMOOC"}};</code></pre></li><li><code>state</code> 的作用域只属于当前的类，不污染其他模块</li></ol><p>部分代码如下：<br><img src="http://oo590vn4k.bkt.clouddn.com/2018011002.png"></p><a id="more"></a><hr><h2 id="2-Props-属性"><a href="#2-Props-属性" class="headerlink" title="2. Props 属性"></a>2. Props 属性</h2><p><img src="http://oo590vn4k.bkt.clouddn.com/2018011003.png"><br>Props 属性：</p><ol><li>Props 对于模块属于外来属性</li><li>传递参数：<pre><code>&lt;Bodyindex username=&apos;parry&apos;&gt;</code></pre></li><li>模块中接受参数：<code>this.props.username</code></li></ol><hr><h2 id="3-事件与数据的双向绑定"><a href="#3-事件与数据的双向绑定" class="headerlink" title="3. 事件与数据的双向绑定"></a>3. 事件与数据的双向绑定</h2><p><small>tips：与暑假实习的代码，类似</small></p><h3 id="3-1-事件的绑定"><a href="#3-1-事件的绑定" class="headerlink" title="3.1 事件的绑定"></a>3.1 事件的绑定</h3><p>注意 ES6 的语法，可以在构造函数里绑定 <code>this</code>:<br>        this.forceUpdateHandler = this.forceUpdateHandler.bind(this)<br>或者 调用时绑定：<br>        onClick= {this.changeUserinfo.bind(this)}</p><h3 id="3-2-子页面向父页面传递参数的方法"><a href="#3-2-子页面向父页面传递参数的方法" class="headerlink" title="3.2 子页面向父页面传递参数的方法"></a>3.2 子页面向父页面传递参数的方法</h3><ol><li>在子页面通过调用父页面传递过来的事件 props 进行组件间的参数传递</li><li>好好理解这里的 <code>onChange</code> 事件，为什么不用 <code>onBlur</code></li></ol><hr><h2 id="4-可复用组件"><a href="#4-可复用组件" class="headerlink" title="4. 可复用组件"></a>4. 可复用组件</h2><h3 id="4-1-Prop-验证"><a href="#4-1-Prop-验证" class="headerlink" title="4.1 Prop 验证"></a>4.1 Prop 验证</h3><p> <a href="http://facebook.github.io/react/docs/reusable-components.html" target="_blank" rel="noopener">http://facebook.github.io/react/docs/reusable-components.html</a><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propTypes = &#123;</span><br><span class="line">id : PropTypes.number.isRequired, <span class="attr">url</span> : PropTypes.string.isRequired, <span class="attr">text</span>:PropTypes:string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BodyIndex.propTypes = &#123;</span><br><span class="line">userid: React.PropTypes.number.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-默认-Prop-值"><a href="#4-2-默认-Prop-值" class="headerlink" title="4.2 默认 Prop 值"></a>4.2 默认 Prop 值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultProps = &#123; <span class="attr">text</span>:<span class="string">'Hello World'</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BodyIndex.defaultProps = defaultProps;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-传递所有参数的快捷方式"><a href="#4-3-传递所有参数的快捷方式" class="headerlink" title="4.3 传递所有参数的快捷方式"></a>4.3 传递所有参数的快捷方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Component &#123;...this.props&#125; more=<span class="string">"values"</span>  /&gt;</span><br></pre></td></tr></table></figure><h2 id="5-组件的-Refs"><a href="#5-组件的-Refs" class="headerlink" title="5. 组件的 Refs"></a>5. 组件的 Refs</h2><p>Refs主要是用来获取原生的html节点来使用的。</p><ol><li><p>原始获取方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line">ReactDOM.findDOMNode(myDiv).style.color = <span class="string">'green'</span>;</span><br></pre></td></tr></table></figure></li><li><p>方法二的定义:<code>&lt;input ref = &quot;myInput&quot; /&gt;</code><br> 方法二的获取:<code>this.refs.myInput</code><br> Refs 是访问到组件内部 DOM 节点唯一可靠的方法<br> 不要在 render 或 render 之前对 Refs  进行调用<br> 不要滥用refs ，影响性能</p><h2 id="6-独立组件间共享-Mixins"><a href="#6-独立组件间共享-Mixins" class="headerlink" title="6. 独立组件间共享 Mixins"></a>6. 独立组件间共享 Mixins</h2></li></ol><p>不同的组件之间共用功能、共享代码<br>官方文档：<a href="https://facebook.github.io/react/docs/reusable-components.html#mixins" target="_blank" rel="noopener">https://facebook.github.io/react/docs/reusable-components.html#mixins</a><br>与页面具有相似的生命周期<br>ES6下需要安装插件 <code>npm install --save react-mixin@2</code><br>关于mixins的讨论文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-State-属性&quot;&gt;&lt;a href=&quot;#1-State-属性&quot; class=&quot;headerlink&quot; title=&quot;1. State 属性&quot;&gt;&lt;/a&gt;1. State 属性&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2018011001.png&quot;&gt;&lt;/center&gt;

&lt;p&gt;State 属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; 对于模块属于自身属性&lt;/li&gt;
&lt;li&gt;初始化: &lt;pre&gt;&lt;code&gt;this.state = {username:&amp;quot;Parry&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;初始化可以放置在构造函数 &lt;code&gt;constructor&lt;/code&gt; 里&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;state&lt;/code&gt;: &lt;pre&gt;&lt;code&gt;this.setState{{username:&quot;IMOOC&quot;}};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; 的作用域只属于当前的类，不污染其他模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;部分代码如下：&lt;br&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2018011002.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>3. React 组件基础</title>
    <link href="https://zhang-hongbin.github.io/2018/01/09/React%20%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhang-hongbin.github.io/2018/01/09/React 组件基础/</id>
    <published>2018-01-09T06:06:46.000Z</published>
    <updated>2018-01-10T11:00:13.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-React-虚拟-DOM-概念"><a href="#1-React-虚拟-DOM-概念" class="headerlink" title="1. React 虚拟 DOM 概念"></a>1. React 虚拟 DOM 概念</h2><h3 id="1-1-虚拟-DOM-的结构"><a href="#1-1-虚拟-DOM-的结构" class="headerlink" title="1.1 虚拟 DOM 的结构"></a>1.1 虚拟 DOM 的结构</h3><center><br><img src="http://oo590vn4k.bkt.clouddn.com/2018010901.png"></center><h3 id="1-2-为什么快？"><a href="#1-2-为什么快？" class="headerlink" title="1.2 为什么快？"></a>1.2 为什么快？</h3><center><img src="http://oo590vn4k.bkt.clouddn.com/2018010902.png"></center><a id="more"></a><h3 id="1-3-如何实现的？"><a href="#1-3-如何实现的？" class="headerlink" title="1.3 如何实现的？"></a>1.3 如何实现的？</h3><center><img src="http://oo590vn4k.bkt.clouddn.com/2018010903.png"></center><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><center><img src="http://oo590vn4k.bkt.clouddn.com/2018010904.png"></center><br><center>图一</center><center><img src="http://oo590vn4k.bkt.clouddn.com/2018010905.png"></center><br><center>图二</center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-React-虚拟-DOM-概念&quot;&gt;&lt;a href=&quot;#1-React-虚拟-DOM-概念&quot; class=&quot;headerlink&quot; title=&quot;1. React 虚拟 DOM 概念&quot;&gt;&lt;/a&gt;1. React 虚拟 DOM 概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-虚拟-DOM-的结构&quot;&gt;&lt;a href=&quot;#1-1-虚拟-DOM-的结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 虚拟 DOM 的结构&quot;&gt;&lt;/a&gt;1.1 虚拟 DOM 的结构&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2018010901.png&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;1-2-为什么快？&quot;&gt;&lt;a href=&quot;#1-2-为什么快？&quot; class=&quot;headerlink&quot; title=&quot;1.2 为什么快？&quot;&gt;&lt;/a&gt;1.2 为什么快？&lt;/h3&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2018010902.png&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件日志</title>
    <link href="https://zhang-hongbin.github.io/2018/01/09/VS%20Code%20%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhang-hongbin.github.io/2018/01/09/VS Code 插件使用/</id>
    <published>2018-01-09T03:06:46.000Z</published>
    <updated>2018-01-10T11:00:41.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS-Code日常插件"><a href="#VS-Code日常插件" class="headerlink" title="VS Code日常插件"></a>VS Code日常插件</h2><p>最早接触的 sublime，之后使用过VS code编辑器后，就爱上了它。类似的开发工具还有ATOM。</p><h3 id="VS-Code插件："><a href="#VS-Code插件：" class="headerlink" title="VS Code插件："></a>VS Code插件：</h3><ol><li>Beautify</li><li>colorize</li><li>HTML Snippets</li><li>JavaScript (ES6)</li><li>JavaScript Snippet</li><li>JS JSX Snippets</li><li>One Dark Pro</li><li>open in browser</li><li>Path Autocomplete</li><li>react-beautify</li><li>React/Redux/react-router Snippets</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VS-Code日常插件&quot;&gt;&lt;a href=&quot;#VS-Code日常插件&quot; class=&quot;headerlink&quot; title=&quot;VS Code日常插件&quot;&gt;&lt;/a&gt;VS Code日常插件&lt;/h2&gt;&lt;p&gt;最早接触的 sublime，之后使用过VS code编辑器后，就爱上
      
    
    </summary>
    
      <category term="VS Code" scheme="https://zhang-hongbin.github.io/categories/VS-Code/"/>
    
    
      <category term="VS Code" scheme="https://zhang-hongbin.github.io/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>2. React 环境配置</title>
    <link href="https://zhang-hongbin.github.io/2018/01/08/React%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhang-hongbin.github.io/2018/01/08/React 环境配置/</id>
    <published>2018-01-08T05:06:46.000Z</published>
    <updated>2018-04-10T13:56:46.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用-NPM-配置-React-环境"><a href="#一、使用-NPM-配置-React-环境" class="headerlink" title="一、使用 NPM 配置 React 环境"></a>一、使用 NPM 配置 React 环境</h2><ol><br><br><li> npm 项目初始化:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><br><br>之后，全部确认即可，生成<code>package.json</code>文件<br></li><br><br><li> 项目依赖包安装:<br><br>- To install React DOM and build your bundle with browserify:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom babelify babel-preset-react babel-loader babel-core</span><br></pre></td></tr></table></figure><br><br>-  if you are using ES2015,you will wangt to also use the <code>babel-preset-es2015</code> package<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-es2015</span><br></pre></td></tr></table></figure><br><br><br></li><br></ol><hr><h2 id="二、-webpack-热加载配置"><a href="#二、-webpack-热加载配置" class="headerlink" title="二、 webpack 热加载配置"></a>二、 webpack 热加载配置</h2><h3 id="2-1-开始："><a href="#2-1-开始：" class="headerlink" title="2.1 开始："></a>2.1 开始：</h3><ol><li>在根目录创建<code>index.html</code></li><li>建立工程文件夹<code>src</code>以及src内的<code>js</code>文件夹,并在<code>js</code>文件夹内创建<code>index.js</code>文件(用于写JSX文件)</li></ol><p>index.html<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>src/bundle.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;Hello World <span class="number">1234556</span>&lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById("example")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p><small><em><br>此时，在<code>index.js</code>以及<code>index.html</code>写入代码后，会发现浏览器无法识别<code>jsx</code>文件类别。因此需要引入<code>webpack</code>工具.<br></em></small></p><h3 id="2-2-项目依赖包安装："><a href="#2-2-项目依赖包安装：" class="headerlink" title="2.2 项目依赖包安装："></a>2.2 项目依赖包安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack webpack-dev-server</span><br></pre></td></tr></table></figure><p><small><br>tips: -g 表示全局安装 webpack<br></small></p><p>之后，项目文件下再安装一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><h3 id="2-3-在根目录创建webpack-config-js文档"><a href="#2-3-在根目录创建webpack-config-js文档" class="headerlink" title="2.3 在根目录创建webpack.config.js文档"></a>2.3 在根目录创建<code>webpack.config.js</code>文档</h3><p>编辑内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: __dirname,</span><br><span class="line">  entry: <span class="string">"./src/js/index.js"</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'react'</span>, <span class="string">'es2015'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname,</span><br><span class="line">    filename: <span class="string">"./src/js/bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>之后执行<code>webpack</code>命令，将进行一次打包   (缺点：内容变更，不能自动打包)</li><li><span style="color:red;">“webpack –watch”命令解决了问题，内容变动，将自动打包</span>（缺点：依然需要手动刷新）</li><li><span style="color:green;">“webpack-dev-server”命令，最终解决了所有问题</span></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline --hot  （此命令，热启动）</span><br></pre></td></tr></table></figure><h3 id="2-4-生成Source-Maps（使调试更容易）"><a href="#2-4-生成Source-Maps（使调试更容易）" class="headerlink" title="2.4 生成Source Maps（使调试更容易）"></a>2.4 生成Source Maps（使调试更容易）</h3><p>在webpack的配置文件中配置source maps，需要配置devtool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-Chrome-React-插件使用"><a href="#3-Chrome-React-插件使用" class="headerlink" title="3. Chrome React 插件使用"></a>3. Chrome React 插件使用</h2><p>插件名：React Developer Tools<br>插件源码与介绍：<a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">https://github.com/facebook/react-devtools</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、使用-NPM-配置-React-环境&quot;&gt;&lt;a href=&quot;#一、使用-NPM-配置-React-环境&quot; class=&quot;headerlink&quot; title=&quot;一、使用 NPM 配置 React 环境&quot;&gt;&lt;/a&gt;一、使用 NPM 配置 React 环境&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>1. React基础知识</title>
    <link href="https://zhang-hongbin.github.io/2018/01/07/React%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhang-hongbin.github.io/2018/01/07/React 基础知识/</id>
    <published>2018-01-07T01:46:46.000Z</published>
    <updated>2018-04-08T11:34:03.850Z</updated>
    
    <content type="html"><![CDATA[<h1>React基础知识</h1><p> </p><h2>一、React 组件基础</h2><br>    <ol><br>        <li>React 虚拟DOM概念，这是React性能高效的核心算法</li><br>        <li>React组件，理解什么叫做组件化      React多组件嵌套 </li><br>        <li>JSX内置表达式</li><br>        <li>生命周期，纵观整个React的生命周期</li><br>    </ol><p></p><p> </p><h2>二、React 属性与事件</h2><br>    <ol><br>        <li>State 属性，掌控着 React 的一切</li><br>        <li>Props 属性 </li><br>        <li>事件与数据的双向绑定，包含了父子页面之间的参数互传</li><br>        <li>可复用组件，真正让 React 开发快速、高效的地方</li><br>        <li>组件的 Refs</li><br>        <li>独立组件间共享 Mixins</li><br>    </ol><p></p><p> </p><h2>三、React 样式</h2><br>     <ol><br>         <li>内联样式</li><br>        <li>内联样式中的表达式 </li><br>        <li>CSS 模块化，学习如何使用 require 进行样式的引用</li><br>        <li>JSX 样式与 CSS 的互转</li><br>        <li>一个非常好用的样式框架 Ant Design 样式框架介绍</li><br>        <li>Ant Design 样式框架使用</li><br>    </ol><p></p><p></p><h2>四、React Router</h2><br>    <ol><br>         <li>Router 概念</li><br>        <li>Router 参数传递 </li><br>    </ol><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;React基础知识&lt;/h1&gt;

&lt;p&gt; &lt;/p&gt;&lt;h2&gt;一、React 组件基础&lt;/h2&gt;&lt;br&gt;    &lt;ol&gt;&lt;br&gt;        &lt;li&gt;React 虚拟DOM概念，这是React性能高效的核心算法&lt;/li&gt;&lt;br&gt;        &lt;li&gt;React组件，理解什么
      
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>BFC 最熟悉的陌生人</title>
    <link href="https://zhang-hongbin.github.io/2017/08/16/BFC%20%E6%9C%80%E7%86%9F%E6%82%89%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/"/>
    <id>https://zhang-hongbin.github.io/2017/08/16/BFC 最熟悉的陌生人/</id>
    <published>2017-08-16T04:06:17.000Z</published>
    <updated>2018-01-08T08:54:02.251Z</updated>
    
    <content type="html"><![CDATA[<p>BFC，你也许听过这个词，但是你可能不是很有底气地解释清楚。<br>写样式的时候，往往加了一个样式或者改了一个属性，就能达到你期望的效果，一切都是如此地神奇。<br>BFC就是神奇之一，它也是最熟悉的陌生人，因为你一不小心就会触发它然而你并没有意识到它正在神奇地发挥作用。</p><h2 id="一、初探BFC"><a href="#一、初探BFC" class="headerlink" title="一、初探BFC"></a>一、初探BFC</h2><p>我们先看看CSS布局的基本单位：</p><ul><li>block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box，并且参与 block formatting context</li><li>inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box，并且参与 inline formatting context</li></ul><p>那这个formatting context又是什么玩意儿？</p><p>它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。</p><p>最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)，这里就不深入研究了。</p><p>BFC定义：它是一个独立的渲染区域，只有block-level box参与，其中的元素按照规定的渲染规则进行布局，并且这个区域与外部毫不相干。</p><a id="more"></a><p>##二、BFC的布局规则与触发规则</p><p>刚才我们说到BFC中的元素有一套规定的布局规则：</p><ul><li>内部的元素会在垂直方向一个接一个地放置</li><li>元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻元素的margin会发生重叠</li><li>每个元素的左外边距与包含块的左边界相接触(对于从左往右，否则相反)，即使存在浮动也是如此</li><li>BFC的区域不会与float元素重叠</li><li>计算BFC的高度时，浮动元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此</li></ul><p>刚才我们又提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素来决定，CSS2.1中规定满足下列CSS声明的元素便会生成BFC（<strong>触发规则</strong>）：</p><ul><li>根元素</li><li>float的值不为none</li><li>overflow的值不为visible</li><li>position的值为absolute或fixed</li><li>display的值为inline-block, table-cell, table-caption, flex, inline-flex<br>注：display: table也认为可以生成BFC，主要原因是table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC<br>上面这些CSS声明的元素生成了BFC，而它们本身并不是BFC，这一点需要区分。</li></ul><h2 id="三、BFC的应用"><a href="#三、BFC的应用" class="headerlink" title="三、BFC的应用"></a>三、BFC的应用</h2><p>说了这么多有用没用的，我们平时布局的时候到底怎么应用呢：</p><h3 id="1-防止垂直margin重叠"><a href="#1-防止垂直margin重叠" class="headerlink" title="1.防止垂直margin重叠"></a>1.防止垂直margin重叠</h3><p>有点布局经验的朋友都知道margin collapse，也就是相邻的垂直元素同时设置了margin后，实际margin值会塌陷到其中较大的那个值。其根本原理就是它们处于同一个BFC，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。</p><p>我们可以在其中一个元素外面包裹一层容器，并触发该容器生成一个BFC。那么两个元素便属于不同的BFC，就不会发生margin重叠了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .wrap&#123;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    p&#123;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">        line-height: 100px;</span></span><br><span class="line"><span class="undefined">        margin: 100px;</span></span><br><span class="line"><span class="undefined">        background: #000;</span></span><br><span class="line"><span class="undefined">        color: #fff;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我属于一个BFC<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我属于另一个BFC<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果是我的话会直接设置200px，或者只设置其中一个元素的margin（懒可以偷，但原理需知道）</p><h3 id="2-防止浮动子元素高度塌陷"><a href="#2-防止浮动子元素高度塌陷" class="headerlink" title="2.防止浮动子元素高度塌陷"></a>2.防止浮动子元素高度塌陷</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .parent&#123;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        border: 3px solid #000;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .child&#123;</span></span><br><span class="line"><span class="undefined">        float: left;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        border: 3px solid #f00;</span></span><br><span class="line"><span class="undefined">        color: #f00;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>float: left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>float: left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们将.parent元素的overflow: hidden去掉，那么.parent元素就获取不到浮动元素的高度了。但是加上overflow属性后触发了BFC，计算BFC的高度时，浮动元素也参与了计算。</p><h3 id="3-防止文字（或其他元素）环绕"><a href="#3-防止文字（或其他元素）环绕" class="headerlink" title="3.防止文字（或其他元素）环绕"></a>3.防止文字（或其他元素）环绕</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .parent&#123;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        border: 3px solid #000;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .child&#123;</span></span><br><span class="line"><span class="undefined">        float: left;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        border: 3px solid #f00;</span></span><br><span class="line"><span class="undefined">        color: #f00;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .text&#123;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>float: left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，如果一个块级元素设置成了float，那么他的兄弟元素会环绕其布局。这里我们给.text加上overflow，文字所在的区域就产生了BFC，元素的左边总是触碰到容器的左边，即使存在浮动也是如此。</p><p>这里举例了几个比较经典的应用，我们在以后的布局中也可以慢慢探索其中的奥秘之处，做一个能写一手好样式还能懂原理的前端er。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BFC，你也许听过这个词，但是你可能不是很有底气地解释清楚。&lt;br&gt;写样式的时候，往往加了一个样式或者改了一个属性，就能达到你期望的效果，一切都是如此地神奇。&lt;br&gt;BFC就是神奇之一，它也是最熟悉的陌生人，因为你一不小心就会触发它然而你并没有意识到它正在神奇地发挥作用。&lt;/p&gt;
&lt;h2 id=&quot;一、初探BFC&quot;&gt;&lt;a href=&quot;#一、初探BFC&quot; class=&quot;headerlink&quot; title=&quot;一、初探BFC&quot;&gt;&lt;/a&gt;一、初探BFC&lt;/h2&gt;&lt;p&gt;我们先看看CSS布局的基本单位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box，并且参与 block formatting context&lt;/li&gt;
&lt;li&gt;inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box，并且参与 inline formatting context&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那这个formatting context又是什么玩意儿？&lt;/p&gt;
&lt;p&gt;它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。&lt;/p&gt;
&lt;p&gt;最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)，这里就不深入研究了。&lt;/p&gt;
&lt;p&gt;BFC定义：它是一个独立的渲染区域，只有block-level box参与，其中的元素按照规定的渲染规则进行布局，并且这个区域与外部毫不相干。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://zhang-hongbin.github.io/categories/CSS/"/>
    
    
      <category term="BFC" scheme="https://zhang-hongbin.github.io/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>React学习指导</title>
    <link href="https://zhang-hongbin.github.io/2017/08/10/React%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC/"/>
    <id>https://zhang-hongbin.github.io/2017/08/10/React学习指导/</id>
    <published>2017-08-10T11:46:46.000Z</published>
    <updated>2017-09-15T01:16:15.884Z</updated>
    
    <content type="html"><![CDATA[<p>虽然学习 React 不难，因为它仅仅是个 view library，但是 React 的整个生态链非常丰富，并且会有很多关于如何学习的方法和资料。</p><p>而我的建议是，在你学习东西的时候需要学习这个技术的前置技术，否则学习起来会很吃力。所以你在开始学习这个技术栈的其他东西之前，下面所列举的内容应该会对你很有帮助：</p><ul><li>JSX 语法</li><li>ReactDOM.render</li><li>使用 setState 来改变组件的状态 state</li><li>组件生命周期相关的方法</li><li>事件和表单</li><li>几种创建组件的方式</li><li>复合组件 composeable</li><li>高阶组件的使用和定义 HOC</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然学习 React 不难，因为它仅仅是个 view library，但是 React 的整个生态链非常丰富，并且会有很多关于如何学习的方法和资料。&lt;/p&gt;
&lt;p&gt;而我的建议是，在你学习东西的时候需要学习这个技术的前置技术，否则学习起来会很吃力。所以你在开始学习这个技术栈的
      
    
    </summary>
    
      <category term="React" scheme="https://zhang-hongbin.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhang-hongbin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>浏览器加载、解析、渲染的过程</title>
    <link href="https://zhang-hongbin.github.io/2017/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E3%80%81%E8%A7%A3%E6%9E%90%E3%80%81%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://zhang-hongbin.github.io/2017/07/10/浏览器加载、解析、渲染的过程/</id>
    <published>2017-07-10T11:46:46.000Z</published>
    <updated>2017-09-08T06:45:14.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习性能优化，学习了<a href="http://www.cnblogs.com/smjack/archive/2009/02/24/1396895.html" target="_blank" rel="noopener">雅虎军规 </a> ，可是觉着有点云里雾里的，因为里面有些东西虽然自己也一直在使用，但是感觉不太明白所以然，比如减少DNS查询，css和<a href="http://lib.csdn.net/base/javascript" style="color:#FF0000" target="_blank" rel="noopener">js</a>文件的顺序。所以就花了时间去了解浏览器的工作，有一篇经典的文章<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">《how browsers work》</a> ，讲的很详细，也有<a href="http://kb.cnblogs.com/page/129756/" target="_blank" rel="noopener">中文译本</a> 。不过就是文章有点太长，也讲了一堆东西，还是自己总结一下。</p><p><br></p><font size="5"><b>为什么要了解浏览器加载、解析、渲染这个过程？</b></font><p>好，我们先说一下，为什么要了解这些呢？如果想写出一个最佳实践的页面，就要好好了解。</p><ul><li>了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</li><li>了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。</li><li>了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。</li></ul><p>正文开始</p><h2 id="一、浏览器的主要功能"><a href="#一、浏览器的主要功能" class="headerlink" title="一、浏览器的主要功能"></a>一、浏览器的主要功能</h2><p>　　<b>浏览器的主要功能</b>是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程，<a href="http://blog.csdn.net/xiaozhuxmen/article/details/51934706" target="_blank" rel="noopener">之前博客中</a>有论述：<br>　　1、输入网址。<br>　　2、浏览器查找域名的IP地址。<br>　　3. 浏览器给web服务器发送一个HTTP请求<br>　　4. 网站服务的永久重定向响应<br>　　5. 浏览器跟踪重定向地址 现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。<br>　　6. 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。<br>　　7. 服务器发回一个HTML响应<br>　　8. 浏览器开始显示HTML<br>　　9. 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p><p><b>那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的：</b></p><h2 id="二、浏览器的渲染"><a href="#二、浏览器的渲染" class="headerlink" title="二、浏览器的渲染"></a>二、浏览器的渲染</h2><p>下面是渲染引擎在取得内容之后的基本流程：<br><code><br>　解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树<br></code></p><a id="more"></a> <p>先来看个图：<br><img src="http://oo590vn4k.bkt.clouddn.com/2017071001.jpg"></p><p>所以，浏览器会解析三个东西：<br>（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。<br>（2） CSS，解析 CSS 会产生 CSS 规则树。<br>（3） <a href="http://lib.csdn.net/base/javascript" style="color:#FF0000" target="_blank" rel="noopener">JavaScript</a>脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.</p><p>我今天又纠结了一上午，到底是怎么解析怎么渲染的，我的疑问在于，浏览器到底是先解析生成了DOM树，然后再加载CSS JS文件进行渲染，还是在生成DOM的过程中，遇到了 link script 然后就加载CSS JS，边加载边渲染。我有这种疑问的原因在于，看网上的帖子，说的根本不一样好嘛！ 比如这篇 我想说，这个写的让我直接懵逼，真的是直接懵逼啊，学习的过程中，总会遇到困难，但这次，让我真的好难啊。不过正因为不懂才继续查资料继续学习嘛 ==！我又查了一上午，自己测试测试测试，然后觉着，我好像是明白点了。真的推荐大家去认真看《how browsers work》这篇文章，学习不懂得知识的时候，还是要从比较权威的资料看起比较好，也不要像我今天这样，无头苍蝇乱查。</p><p>那么就来说一下图中的过程，我是按照自己的理解来说，如果有误，欢迎指正。</p><p><code><br>    当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。<br>    解析： </code></p><pre><code>1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 2. 将CSS解析成 CSS Rule Tree 。 3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。</code></pre><p></p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017071002.jpg"></p><pre><code>4.有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 5.再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</code></pre><p>&lt;br/ &gt;</p><big><big><big><strong>重点来了：</strong></big></big></big><p>　　上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。（这段话是《how browsers work》里面讲的，让我茅塞顿开）</p><h3 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h3><p>（1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</p><p>（2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 </p><p>Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。</p><h4 id="reflow的原因："><a href="#reflow的原因：" class="headerlink" title="reflow的原因："></a>reflow的原因：</h4><p>（1）页面初始化的时候；<br>（2）操作DOM时；<br>（3）某些元素的尺寸变了；<br>（4）如果 CSS 的属性发生变化了。</p><h4 id="减少-reflow-repaint"><a href="#减少-reflow-repaint" class="headerlink" title="减少 reflow/repaint"></a>减少 reflow/repaint</h4><p>　（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p><p>　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 </p><p>　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p><p>　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p><p>我应该是已经把网上所有的关于浏览器加载 解析 渲染过程的文章都看全了，其中写的比较好的一个版本是下面这个：</p><p>&lt;br/ &gt;</p><div style="background:lightgrey;"><br><div style="padding-left:20px;background:RGB(249,249,249);"><br><b><a href="http://blog.csdn.net/xifeijian/article/details/10813339" target="_blank" rel="noopener">HTML页面加载和解析流程</a> </b><br>1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；<br>2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；<br>3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；<br>4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；<br>5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；<br>6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；<br>7. 浏览器发现了一个包含一行javascript代码的＜script＞标签，赶快运行它；<br>8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；<br>9. 终于等到了＜/html＞的到来，浏览器泪流满面……<br>10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；<br>11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。<br></div><br></div><h2 id="与讨论主题相关的其他思考"><a href="#与讨论主题相关的其他思考" class="headerlink" title="与讨论主题相关的其他思考"></a>与讨论主题相关的其他思考</h2><h3 id="编写CSS时应该注意："><a href="#编写CSS时应该注意：" class="headerlink" title="编写CSS时应该注意："></a>编写CSS时应该注意：</h3><p>CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意：</p><ol><li>dom深度尽量浅。</li><li>减少inline javascript、css的数量。</li><li>使用现代合法的css属性。</li><li>不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。</li><li>避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp&gt;p{}</li><li>避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.</li></ol><h3 id="关于script标签的位置"><a href="#关于script标签的位置" class="headerlink" title="关于script标签的位置"></a>关于script标签的位置</h3><p><b>现在，我们大都会将script标签放在body结束标签之前，那原因是什么呢？</b>我今天也做了一个测试。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试js代码位置<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> item = <span class="built_in">document</span>.getElementById(<span class="string">"item"</span>);</span></span><br><span class="line"><span class="undefined">        cosole.log(item);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"item"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">        你好</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中有一段js代码，要在控制台打印一个元素，我把script标签放在head里，控制台里打印出来的是null。 </p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017071005.jpg"></p><p>我又把js代码放在body结束标签之前，打印出来的就是div元素了 </p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017071003.jpg"></p><p>所以，通过这个简单的例子我们可以看到，js代码在加载完后，是立即执行的。<br>我又做了一个测试，在js代码里面写了一个死循环，把它放在head标签中，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试js代码位置<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> item = <span class="built_in">document</span>.getElementById(<span class="string">"item"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"item"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">        你好</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面是这样的：<br><img src="http://oo590vn4k.bkt.clouddn.com/2017071004.jpg"></p><p>一直在执行那个打印1的死循环，后面的body都没有加载渲染出来。所以，这个小例子，我们可以看出，js的下载和执行会阻塞Dom树的构建。</p><p><b>所以，Javascript的加载和执行的特点： </b><br>（1）载入后马上执行；<br>（2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。</p><h3 id="减少-JavaScript-对性能的影响的方法："><a href="#减少-JavaScript-对性能的影响的方法：" class="headerlink" title="减少 JavaScript 对性能的影响的方法："></a>减少 JavaScript 对性能的影响的方法：</h3><ol><li>将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。</li><li>尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。</li><li>采用无阻塞下载 JavaScript 脚本的方法：<br>（1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；<br>（2）使用动态创建的script元素来下载并执行代码；</li></ol><p>好了，写到这里吧，我想静静。</p><hr><p>转自：<a href="http://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">http://blog.csdn.net/xiaozhuxmen/article/details/52014901</a><br>作者：季诗筱</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习性能优化，学习了&lt;a href=&quot;http://www.cnblogs.com/smjack/archive/2009/02/24/1396895.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雅虎军规 &lt;/a&gt; ，可是觉着有点云里雾里的，因为里面有些东西虽然自己也一直在使用，但是感觉不太明白所以然，比如减少DNS查询，css和&lt;a href=&quot;http://lib.csdn.net/base/javascript&quot; style=&quot;color:#FF0000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js&lt;/a&gt;文件的顺序。所以就花了时间去了解浏览器的工作，有一篇经典的文章&lt;a href=&quot;http://taligarsiel.com/Projects/howbrowserswork1.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《how browsers work》&lt;/a&gt; ，讲的很详细，也有&lt;a href=&quot;http://kb.cnblogs.com/page/129756/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文译本&lt;/a&gt; 。不过就是文章有点太长，也讲了一堆东西，还是自己总结一下。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;font size=&quot;5&quot;&gt;&lt;b&gt;为什么要了解浏览器加载、解析、渲染这个过程？&lt;/b&gt;&lt;/font&gt;

&lt;p&gt;好，我们先说一下，为什么要了解这些呢？如果想写出一个最佳实践的页面，就要好好了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。&lt;/li&gt;
&lt;li&gt;了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。&lt;/li&gt;
&lt;li&gt;了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正文开始&lt;/p&gt;
&lt;h2 id=&quot;一、浏览器的主要功能&quot;&gt;&lt;a href=&quot;#一、浏览器的主要功能&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器的主要功能&quot;&gt;&lt;/a&gt;一、浏览器的主要功能&lt;/h2&gt;&lt;p&gt;　　&lt;b&gt;浏览器的主要功能&lt;/b&gt;是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。整个浏览器工作的流程，&lt;a href=&quot;http://blog.csdn.net/xiaozhuxmen/article/details/51934706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;之前博客中&lt;/a&gt;有论述：&lt;br&gt;　　1、输入网址。&lt;br&gt;　　2、浏览器查找域名的IP地址。&lt;br&gt;　　3. 浏览器给web服务器发送一个HTTP请求&lt;br&gt;　　4. 网站服务的永久重定向响应&lt;br&gt;　　5. 浏览器跟踪重定向地址 现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。&lt;br&gt;　　6. 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。&lt;br&gt;　　7. 服务器发回一个HTML响应&lt;br&gt;　　8. 浏览器开始显示HTML&lt;br&gt;　　9. 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…&lt;/p&gt;
&lt;p&gt;&lt;b&gt;那么，一个页面，究竟是如何从我们输入一个网址到最后完整的呈现在我们面前的呢？还需要了解一下浏览器是如何渲染的：&lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、浏览器的渲染&quot;&gt;&lt;a href=&quot;#二、浏览器的渲染&quot; class=&quot;headerlink&quot; title=&quot;二、浏览器的渲染&quot;&gt;&lt;/a&gt;二、浏览器的渲染&lt;/h2&gt;&lt;p&gt;下面是渲染引擎在取得内容之后的基本流程：&lt;br&gt;&lt;code&gt;&lt;br&gt;　解析html以构建dom树 -&amp;gt; 构建render树 -&amp;gt; 布局render树 -&amp;gt; 绘制render树&lt;br&gt;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="十二、运行环境" scheme="https://zhang-hongbin.github.io/categories/%E5%8D%81%E4%BA%8C%E3%80%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="DOM树" scheme="https://zhang-hongbin.github.io/tags/DOM%E6%A0%91/"/>
    
      <category term="渲染" scheme="https://zhang-hongbin.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="reflow" scheme="https://zhang-hongbin.github.io/tags/reflow/"/>
    
      <category term="repaint" scheme="https://zhang-hongbin.github.io/tags/repaint/"/>
    
  </entry>
  
  <entry>
    <title>十二、运行环境</title>
    <link href="https://zhang-hongbin.github.io/2017/07/08/%E5%8D%81%E4%BA%8C%E3%80%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://zhang-hongbin.github.io/2017/07/08/十二、运行环境/</id>
    <published>2017-07-08T11:46:46.000Z</published>
    <updated>2017-09-07T07:57:47.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2><pre><code>题目：        1. 从输入url到得到html的详细过程    2. window.onload 和 DOMContentLoaded 的区别知识点：    1. 加载资源的形式        ⑴输入url（或跳转页面）加载html        ⑵加载html中的静态资源，例如 &lt;script src=“/static/ js / jquery.js”&gt;&lt;/script&gt;    2. 加载一个资源的过程</code></pre> <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070801.JPG"></center><pre><code>3. 浏览器渲染页面的过程    ⑴ 根据HTML结构生成DOM Tree    ⑵ 根据CSS生成CSSOM    ⑶ 将DOM 和 CSSOM 整合形成RenderTree    ⑷ 根据 RenderTree 开始渲染和展示    ⑸ 遇到script标签时，会执行并阻塞渲染    思考：为何要把js放在body最下面    答：如果放在上面，&lt;script&gt;会阻塞渲染。另外，放在上面，无法拿到&lt;script&gt;以下的标签。</code></pre>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070802.JPG"></center><a id="more"></a><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070803.JPG"></center><pre><code>原则：    ⑴ 多使用内存、缓存 或者 其他方法    ⑵ 减少CPU计算、减少网络从哪里入手：    ①加载页面和静态资源        ⁃    静态资源的压缩合并        ⁃    静态资源缓存        ⁃    使用CDN让资源加载更快        ⁃    使用SSR后端渲染，数据直接输出到HTML中    ②渲染优化        ⁃    CSS放在前面，JS放后面        ⁃    懒加载（图片懒加载、下拉加载更多）        ⁃    减少DOM查询，对DOM查询做缓存</code></pre>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070804.JPG"></center><pre><code>⁃    减少DOM操作，多个操作尽量合并在一起</code></pre>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070805.JPG"></center><pre><code>⁃    事件节流</code></pre>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070806.JPG"></center><pre><code>⁃    尽早执行操作（如DOMContentLoaded）</code></pre><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="XSS-跨站请求攻击"><a href="#XSS-跨站请求攻击" class="headerlink" title="XSS 跨站请求攻击"></a>XSS 跨站请求攻击</h3>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070807.JPG"></center><br>解决：<br>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070808.JPG"></center><h3 id="XSRF-跨站请求伪造"><a href="#XSRF-跨站请求伪造" class="headerlink" title="XSRF  跨站请求伪造"></a>XSRF  跨站请求伪造</h3>  <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070809.JPG"></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;页面加载过程&quot;&gt;&lt;a href=&quot;#页面加载过程&quot; class=&quot;headerlink&quot; title=&quot;页面加载过程&quot;&gt;&lt;/a&gt;页面加载过程&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;题目：    
    1. 从输入url到得到html的详细过程
    2. window.onload 和 DOMContentLoaded 的区别
知识点：
    1. 加载资源的形式
        ⑴输入url（或跳转页面）加载html
        ⑵加载html中的静态资源，例如 &amp;lt;script src=“/static/ js / jquery.js”&amp;gt;&amp;lt;/script&amp;gt;
    2. 加载一个资源的过程
&lt;/code&gt;&lt;/pre&gt; &lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070801.JPG&quot;&gt;&lt;/center&gt;

&lt;pre&gt;&lt;code&gt;3. 浏览器渲染页面的过程
    ⑴ 根据HTML结构生成DOM Tree
    ⑵ 根据CSS生成CSSOM
    ⑶ 将DOM 和 CSSOM 整合形成RenderTree
    ⑷ 根据 RenderTree 开始渲染和展示
    ⑸ 遇到script标签时，会执行并阻塞渲染


    思考：为何要把js放在body最下面
    答：如果放在上面，&amp;lt;script&amp;gt;会阻塞渲染。另外，放在上面，无法拿到&amp;lt;script&amp;gt;以下的标签。
&lt;/code&gt;&lt;/pre&gt;  &lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070802.JPG&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="十二、运行环境" scheme="https://zhang-hongbin.github.io/categories/%E5%8D%81%E4%BA%8C%E3%80%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="git" scheme="https://zhang-hongbin.github.io/tags/git/"/>
    
      <category term="webpack" scheme="https://zhang-hongbin.github.io/tags/webpack/"/>
    
      <category term="模块化" scheme="https://zhang-hongbin.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>十一、关于开发环境</title>
    <link href="https://zhang-hongbin.github.io/2017/07/06/%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://zhang-hongbin.github.io/2017/07/06/十一、关于开发环境/</id>
    <published>2017-07-06T11:46:46.000Z</published>
    <updated>2017-09-07T09:28:03.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-IDE（写代码的效率）"><a href="#1-IDE（写代码的效率）" class="headerlink" title="1. IDE（写代码的效率）"></a>1. IDE（写代码的效率）</h2><h2 id="2-git（代码版本管理，多人协作开发）"><a href="#2-git（代码版本管理，多人协作开发）" class="headerlink" title="2. git（代码版本管理，多人协作开发）"></a>2. git（代码版本管理，多人协作开发）</h2><h2 id="3-JS模块化"><a href="#3-JS模块化" class="headerlink" title="3. JS模块化"></a>3. JS模块化</h2><pre><code>⑴ 不使用模块化的情况⑵ 使用模块化的情况</code></pre><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070601.JPG"></center><pre><code>⑶ AMD    *  require.js    * 全局 define 函数    * 全局 require 函数    * 依赖js会自动、异步加载</code></pre><a id="more"></a><p>⑷CommonJS</p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070602.JPG"></center><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070603.JPG"></center><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070604.JPG"></center><h2 id="4-打包工具"><a href="#4-打包工具" class="headerlink" title="4. 打包工具"></a>4. 打包工具</h2><h2 id="5-上线回滚的流程"><a href="#5-上线回滚的流程" class="headerlink" title="5. 上线回滚的流程"></a>5. 上线回滚的流程</h2><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070605.JPG"></center><pre><code>上线流程要点：        ⑴将测试完成的代码提交到git版本库的master        ⑵将当前服务器的代码全部打包并记录版本号，备份        ⑶将master分支的代码提交覆盖到线上服务器，生成新版本号</code></pre><h2 id="6-linux基本命令"><a href="#6-linux基本命令" class="headerlink" title="6. linux基本命令"></a>6. linux基本命令</h2><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070606.JPG"></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-IDE（写代码的效率）&quot;&gt;&lt;a href=&quot;#1-IDE（写代码的效率）&quot; class=&quot;headerlink&quot; title=&quot;1. IDE（写代码的效率）&quot;&gt;&lt;/a&gt;1. IDE（写代码的效率）&lt;/h2&gt;&lt;h2 id=&quot;2-git（代码版本管理，多人协作开发）&quot;&gt;&lt;a href=&quot;#2-git（代码版本管理，多人协作开发）&quot; class=&quot;headerlink&quot; title=&quot;2. git（代码版本管理，多人协作开发）&quot;&gt;&lt;/a&gt;2. git（代码版本管理，多人协作开发）&lt;/h2&gt;&lt;h2 id=&quot;3-JS模块化&quot;&gt;&lt;a href=&quot;#3-JS模块化&quot; class=&quot;headerlink&quot; title=&quot;3. JS模块化&quot;&gt;&lt;/a&gt;3. JS模块化&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;⑴ 不使用模块化的情况
⑵ 使用模块化的情况
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070601.JPG&quot;&gt;&lt;/center&gt;


&lt;pre&gt;&lt;code&gt;⑶ AMD
    *  require.js
    * 全局 define 函数
    * 全局 require 函数
    * 依赖js会自动、异步加载
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="十一、关于开发环境" scheme="https://zhang-hongbin.github.io/categories/%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Git" scheme="https://zhang-hongbin.github.io/tags/Git/"/>
    
      <category term="webpack" scheme="https://zhang-hongbin.github.io/tags/webpack/"/>
    
      <category term="模块化" scheme="https://zhang-hongbin.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>十、存储</title>
    <link href="https://zhang-hongbin.github.io/2017/07/05/%E5%8D%81%E3%80%81%E5%AD%98%E5%82%A8/"/>
    <id>https://zhang-hongbin.github.io/2017/07/05/十、存储/</id>
    <published>2017-07-05T11:46:46.000Z</published>
    <updated>2017-09-07T09:24:28.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><pre><code>1.cookie    • 本身用于客户端和服务器端通信    • 但是它有本身存储的功能，于是就被“借用”     • 使用document.cookie = … 获取和修改即可</code></pre> <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070501.JPG"></center><pre><code>2.locationStorage 和 sessionStorage</code></pre> <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070502.JPG"></center><br>        sessionStorage 关闭，会自动清理存储数据。<br><br><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070503.JPG"></center><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070504.JPG"></center><a id="more"></a><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><pre><code>请描述一下cookie，sessionStorage 和 localStorage的区别？</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.cookie
    • 本身用于客户端和服务器端通信
    • 但是它有本身存储的功能，于是就被“借用” 
    • 使用document.cookie = … 获取和修改即可
&lt;/code&gt;&lt;/pre&gt; &lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070501.JPG&quot;&gt;&lt;/center&gt;


&lt;pre&gt;&lt;code&gt;2.locationStorage 和 sessionStorage
&lt;/code&gt;&lt;/pre&gt; &lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070502.JPG&quot;&gt;&lt;/center&gt;&lt;br&gt;        sessionStorage 关闭，会自动清理存储数据。&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070503.JPG&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070504.JPG&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="十、存储" scheme="https://zhang-hongbin.github.io/categories/%E5%8D%81%E3%80%81%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="cookie" scheme="https://zhang-hongbin.github.io/tags/cookie/"/>
    
      <category term="locationStorage" scheme="https://zhang-hongbin.github.io/tags/locationStorage/"/>
    
      <category term="sessionStorage" scheme="https://zhang-hongbin.github.io/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>九、Ajax</title>
    <link href="https://zhang-hongbin.github.io/2017/07/04/%E4%B9%9D%E3%80%81Ajax/"/>
    <id>https://zhang-hongbin.github.io/2017/07/04/九、Ajax/</id>
    <published>2017-07-04T11:46:46.000Z</published>
    <updated>2017-09-06T04:51:09.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><pre><code>1. XMLHttpRequest</code></pre> <center><img src="http://oo590vn4k.bkt.clouddn.com/2017070401.JPG"></center><pre><code>2. 状态码说明3. 跨域⑴ 什么是跨域    • 浏览器有同源策略，不允许ajax访问其他接口    • 跨域条件：协议、域名、端口，有一个不同就算跨域    • 可以跨域的三个标签    • &lt;img src=xxx&gt;    • &lt;link href=xxx&gt;    • &lt;script src=xxx&gt;    • 三个标签的场景</code></pre><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070402.JPG"></center><br>    ⑵ JSONP<br><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070404.JPG"></center><br>    ⑶ 服务器端设置http header<br><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070403.JPG"></center><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><pre><code>1. 手动编写Ajax，不依赖第三方库2. 跨域的几种实现方式</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. XMLHttpRequest
&lt;/code&gt;&lt;/pre&gt; &lt;center&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="九、Ajax" scheme="https://zhang-hongbin.github.io/categories/%E4%B9%9D%E3%80%81Ajax/"/>
    
    
      <category term="状态码" scheme="https://zhang-hongbin.github.io/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
      <category term="XMLHttpRequest" scheme="https://zhang-hongbin.github.io/tags/XMLHttpRequest/"/>
    
      <category term="跨域" scheme="https://zhang-hongbin.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>八、事件</title>
    <link href="https://zhang-hongbin.github.io/2017/07/04/%E5%85%AB%E3%80%81%E4%BA%8B%E4%BB%B6/"/>
    <id>https://zhang-hongbin.github.io/2017/07/04/八、事件/</id>
    <published>2017-07-04T01:46:46.000Z</published>
    <updated>2017-09-07T09:24:51.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><pre><code>1. 通用事件绑定2. 事件冒泡3. 代理</code></pre><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070405.jpg"></center><br>&gt;<br><br><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070406.jpg"></center><pre><code>代理的好处：    ⑴代码简洁    ⑵减少浏览器内存占用</code></pre><a id="more"></a><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><pre><code>1. 编写一个通用的事件监听函数</code></pre><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070407.jpg"></center><p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070408.jpg"></center></p><pre><code>2. 描述事件冒泡流程答：    • DOM树形结构    • 事件冒泡    • 阻止冒泡    • 冒泡的应用（代理）         3. 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件    答：    • 使用代理    • 知道代理的两个优点</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 通用事件绑定
2. 事件冒泡
3. 代理
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070405.jpg&quot;&gt;&lt;/center&gt;&lt;br&gt;&amp;gt;&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070406.jpg&quot;&gt;&lt;/center&gt;


&lt;pre&gt;&lt;code&gt;代理的好处：
    ⑴代码简洁
    ⑵减少浏览器内存占用
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="八、事件" scheme="https://zhang-hongbin.github.io/categories/%E5%85%AB%E3%80%81%E4%BA%8B%E4%BB%B6/"/>
    
    
      <category term="事件" scheme="https://zhang-hongbin.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="冒泡" scheme="https://zhang-hongbin.github.io/tags/%E5%86%92%E6%B3%A1/"/>
    
      <category term="代理" scheme="https://zhang-hongbin.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>七、BOM操作</title>
    <link href="https://zhang-hongbin.github.io/2017/07/03/%E4%B8%83%E3%80%81BOM%E6%93%8D%E4%BD%9C/"/>
    <id>https://zhang-hongbin.github.io/2017/07/03/七、BOM操作/</id>
    <published>2017-07-03T01:46:46.000Z</published>
    <updated>2017-09-02T11:40:49.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h2><pre><code>1. navigator(常用)    </code></pre><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070301.JPG"></p><pre><code>2. screen3. location（常用）</code></pre><p> <img src="http://oo590vn4k.bkt.clouddn.com/2017070302.JPG"></p><pre><code>4.  history</code></pre><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070303.JPG"></p><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><pre><code>1. 如何检测浏览器的类型</code></pre><p>  <img src="http://oo590vn4k.bkt.clouddn.com/2017070304.JPG"></p><pre><code>2. 拆解url的各部分 </code></pre><p> <img src="http://oo590vn4k.bkt.clouddn.com/2017070302.JPG"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点:&quot;&gt;&lt;/a&gt;知识点:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. navigator(常用)    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://oo
      
    
    </summary>
    
      <category term="七、BOM操作" scheme="https://zhang-hongbin.github.io/categories/%E4%B8%83%E3%80%81BOM%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="navigator" scheme="https://zhang-hongbin.github.io/tags/navigator/"/>
    
      <category term="location" scheme="https://zhang-hongbin.github.io/tags/location/"/>
    
      <category term="history" scheme="https://zhang-hongbin.github.io/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>详解setTimeOut面试题</title>
    <link href="https://zhang-hongbin.github.io/2017/07/02/%E8%AF%A6%E8%A7%A3setTimeOut%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhang-hongbin.github.io/2017/07/02/详解setTimeOut面试题/</id>
    <published>2017-07-02T07:33:12.000Z</published>
    <updated>2017-09-01T07:22:36.195Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一道很有意思的前端面试题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求改动上述代码，使其依次输出1、2、3、4、5</span></span><br></pre></td></tr></table></figure></p><p>这道题涉及到的知识点有<code>函数的执行顺序</code>、<code>闭包</code>、<code>块级作用域</code>等。</p><p>首先，我们可以来看一下这道题原本会输出的结果是什么</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070210.png"></p><p>如图，执行这段代码之后，立即输出了一个数字89，然后每过1秒钟输出了一个数字6</p><h2 id="setTimeout-相关知识"><a href="#setTimeout-相关知识" class="headerlink" title="setTimeout()相关知识"></a>setTimeout()相关知识</h2><p>在我们学习<small><font color="purple">setTimeout</font></small>的时候就知道，<small><font color="purple">setTimeout</font></small>有两个参数，第一个参数是回调函数，第二个参数是毫秒数，表示要执行回调函数所要延迟的时间。</p><p>但我们还需要知道的是，<font color="purple">setTimeout</font>会返回一个<font color="purple">Id</font>，即这个定时器的<font color="purple">Id</font>，在上面的代码中其实已经创建了5个定时器，但是默认只返回了最后的一个<font color="purple">Id</font>，我们可以通过将<font color="purple">Id</font>赋值给一个变量，来看到这个过程。</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070211.png"></p><a id="more"></a><p>由于方法里面没有<font color="purple">return</font>任何东西出来，所以返回值为<font color="purple">undefined</font>。</p><p>通过这个定时器的Id，可以使用<font color="purple">clearTimeout(id)</font>方法清除掉这个定时器，这里就不再赘述了。</p><p>接下来就该讨论为什么会输出5个数字6，而不是1、2、3、4、5了。先来看一个例子</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070212.png"></p><p>当<font color="purple">setTimeout()</font>的毫秒数设置为0的时候，仍然是先执行完函数调用栈中的代码，然后立即调用定时器。这是因为，我们的定时器都被放在了一个被称为队列的数据结构中，等待上下文的可执行代码运行完毕后，才开始运行定时器，也就是定时器才刚开始计时。</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070213.png"></p><p>例子如下：</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070214.png"></p><p>所以在定时器的方法执行的时候，变量i已经变成了6，所以输出的全部是6。因为5个定时器所打印出来的是同一个i变量，所以想要实现输出不同的数字，就需要把每个定时器所访问的变量独立起来，这就用到了JavaScript的闭包。</p><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p>我们都知道，JavaScript的变量是从外往内开放的，函数内部可以访问到外部的变量，但是外部无法访问到内部。</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070215.png"></p><p>内部的<font color="red">func()</font>方法就形成了一个闭包，闭包用途很多，可以很好地区分开各个作用域，避免变量的混淆，但是滥用闭包也会导致性能问题。</p><p>想要使用闭包完成文章开始的面试题，可以通过以下的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(i);</span><br><span class="line">          &#125;, i * <span class="number">1000</span> );</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//上面的代码是标准答案，将变量i作为参数传到闭包中</span></span><br><span class="line"><span class="comment">//我们也可以通过作用域在函数内部把变量隔离起来</span></span><br><span class="line"><span class="comment">//其实，在闭包内部访问i的时候，i就是一个常量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = i;<span class="comment">//把i赋值给另外一个变量</span></span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(s);</span><br><span class="line">          &#125;, s * <span class="number">1000</span> );</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，也可以把setTimeout的回调函数做成一个闭包，同样能得到正确的结果。</span></span><br></pre></td></tr></table></figure></p><h2 id="块级作用域–关键字let"><a href="#块级作用域–关键字let" class="headerlink" title="块级作用域–关键字let"></a>块级作用域–关键字let</h2><p>使用闭包可以得到正确的结果，原因就是改变了i的作用域，那如果我们把循环中的每个setTimeout都独立成一个作用域是不是也能实现同样的结果呢？</p><p>我们都知道，在JavaScript中，每个函数是一个独立的作用域，但是“{}”是不能形成独立作用域的。</p><p>在ES6中提出了一个新的关键字<font color="red">let</font>，就可以声明一个仅对当前<font color="red">“{}”</font>内部有作用的变量。</p><p><img src="http://oo590vn4k.bkt.clouddn.com/2017070216.png"></p><p>如图，同样可以实现。</p><p>总结<br>这个面试题考察了setTimeout方法的原理，间接涉及了函数调用栈。利用闭包或块级作用域可以实现想要的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一道很有意思的前端面试题&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, i * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//要求改动上述代码，使其依次输出1、2、3、4、5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这道题涉及到的知识点有&lt;code&gt;函数的执行顺序&lt;/code&gt;、&lt;code&gt;闭包&lt;/code&gt;、&lt;code&gt;块级作用域&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;首先，我们可以来看一下这道题原本会输出的结果是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070210.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，执行这段代码之后，立即输出了一个数字89，然后每过1秒钟输出了一个数字6&lt;/p&gt;
&lt;h2 id=&quot;setTimeout-相关知识&quot;&gt;&lt;a href=&quot;#setTimeout-相关知识&quot; class=&quot;headerlink&quot; title=&quot;setTimeout()相关知识&quot;&gt;&lt;/a&gt;setTimeout()相关知识&lt;/h2&gt;&lt;p&gt;在我们学习&lt;small&gt;&lt;font color=&quot;purple&quot;&gt;setTimeout&lt;/font&gt;&lt;/small&gt;的时候就知道，&lt;small&gt;&lt;font color=&quot;purple&quot;&gt;setTimeout&lt;/font&gt;&lt;/small&gt;有两个参数，第一个参数是回调函数，第二个参数是毫秒数，表示要执行回调函数所要延迟的时间。&lt;/p&gt;
&lt;p&gt;但我们还需要知道的是，&lt;font color=&quot;purple&quot;&gt;setTimeout&lt;/font&gt;会返回一个&lt;font color=&quot;purple&quot;&gt;Id&lt;/font&gt;，即这个定时器的&lt;font color=&quot;purple&quot;&gt;Id&lt;/font&gt;，在上面的代码中其实已经创建了5个定时器，但是默认只返回了最后的一个&lt;font color=&quot;purple&quot;&gt;Id&lt;/font&gt;，我们可以通过将&lt;font color=&quot;purple&quot;&gt;Id&lt;/font&gt;赋值给一个变量，来看到这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070211.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="四、异步和单线程" scheme="https://zhang-hongbin.github.io/categories/%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="异步" scheme="https://zhang-hongbin.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="setTimeout" scheme="https://zhang-hongbin.github.io/tags/setTimeout/"/>
    
  </entry>
  
  <entry>
    <title>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</title>
    <link href="https://zhang-hongbin.github.io/2017/07/02/%E6%9C%80%E8%AF%A6%E5%B0%BD%E7%9A%84-JS-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%88%E6%9E%81%E8%AF%A6%E8%A7%A3%EF%BC%8C%E6%B2%A1%E6%9C%89%E3%80%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E3%80%8D%E3%80%82%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://zhang-hongbin.github.io/2017/07/02/最详尽的-JS-原型与原型链终极详解，没有「可能是」。（三）/</id>
    <published>2017-07-02T04:33:12.000Z</published>
    <updated>2017-09-02T11:01:14.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七-函数对象-（复习一下前面的知识点）"><a href="#七-函数对象-（复习一下前面的知识点）" class="headerlink" title="七. 函数对象 （复习一下前面的知识点）"></a>七. 函数对象 （复习一下前面的知识点）</h2><p><b>所有函数对象的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<b><strong>__</strong>proto____</b>是Object.prototype。如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面说的<b>函数对象</b>当然包括自定义的。如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> Perosn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Man.__proto__ === <span class="built_in">Function</span>.prototype)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这说明什么呢？<br><a id="more"></a><br><b><br>所有的构造器都来自于 <font color="purple">Function.prototype</font>，甚至包括根构造器<font color="purple">Object</font>及<font color="purple">Function</font>自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind</b></p><p>（你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：））<br>Function.prototype也是唯一一个<font color="purple">typeof XXX.prototype</font>为 <font color="purple">function</font>的<font color="purple">prototype</font>。其它的构造器的<font color="purple">prototype</font>都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)     <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>噢，上面还提到它是一个空的函数，<font color="purple">console.log(Function.prototype)</font> 下看看（留意，下一节会再说一下这个）</p><p>知道了所有构造器（含内置及自定义）的<font color="purple"><strong>proto</strong></font>都是<font color="purple">Function.prototype</font>，那<font color="purple">Function.prototype</font>的<font color="purple"><strong>__</strong>proto__</font>是谁呢？<br>相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；））</p><p>最后Object.prototype的<b>proto</b>是谁？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>已经到顶了，为null。(读到现在，再回过头看第五章，能明白吗？)</p><p></p><h2> 八. Prototype </h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</span><br></pre></td></tr></table></figure><p></p><p>——《JavaScript 高级程序设计》第三版 P116</p><p>我们知道 JS 内置了一些方法供我们使用，比如：<br>对象可以用 <font color="purple">constructor/toString()/valueOf()</font> 等方法;<br>数组可以用 <font color="purple">map()/filter()/reducer()</font> 等方法；<br>数字可用用 <font color="purple">parseInt()/parseFloat()</font>等方法；<br>Why ？？？</p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070201.jpg"></center><center><u><font color="grey">why??</font></u></center><p><b>当我们创建一个函数时：</b></p><font color="purple">var Person = new Object()</font><br><font color="purple">Person</font> 是 <font color="purple">Object</font> 的实例，所以 <font color="purple">Person</font> <b>继承了</b><font color="purple">Object</font> 的原型对象<font color="purple">Object.prototype</font>上所有的方法：<br><br><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070205.jpg"></center><br><center><u><font color="grey">Object.prototype</font></u></center><br><br><br><b>Object 的每个实例都具有以上的属性和方法。</b><br>所以我可以用 <font color="purple">Person.constructor </font>也可以用 <font color="purple">Person.hasOwnProperty</font>。<br><br><b>当我们创建一个数组时：</b><br><br><font color="purple">var num = new Array()</font><p><font color="purple">num</font> 是 <font color="purple">Array</font> 的实例，所以<font color="purple"> num</font> 继承了<font color="purple">Array </font>的原型对象<font color="purple">Array.prototype</font>上所有的方法：<br><br></p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070206.jpg"></center><br><center><u><font color="grey">Array.prototype</font></u></center><p>Are you f***ing kidding me? 这尼玛怎么是一个空数组？？？<br><br></p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070202.jpg"></center><br><center><u><font color="grey">doge</font></u></center><p>我们可以用一个 ES5 提供的新方法：<font color="purple">Object.getOwnPropertyNames</font><br>获取所有（<b>包括不可枚举的属性</b>）的属性名<b>不包括</b> <font color="purple">prototy</font> <b>中的属性</b>，返回一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayAllKeys = <span class="built_in">Array</span>.prototype; <span class="comment">// [] 空数组</span></span><br><span class="line"><span class="comment">// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(arrayAllKeys)); </span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">["length", "constructor", "toString", "toLocaleString", "join", "pop", "push", </span></span><br><span class="line"><span class="comment">"concat", "reverse", "shift", "unshift", "slice", "splice", "sort", "filter", "forEach", </span></span><br><span class="line"><span class="comment">"some", "every", "map", "indexOf", "lastIndexOf", "reduce", "reduceRight", </span></span><br><span class="line"><span class="comment">"entries", "keys", "copyWithin", "find", "findIndex", "fill"]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</p><p>细心的你肯定发现了<font color="purple">Object.getOwnPropertyNames(arrayAllKeys)</font> 输出的数组里并没有 <font color="purple">constructor/hasOwnPrototype</font>等<b>对象</b>的方法（你肯定没发现）。<br>但是随便定义的数组也能用这些方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(num.hasOwnPrototype()) <span class="comment">// false (输出布尔值而不是报错)</span></span><br></pre></td></tr></table></figure><p>Why ？？？</p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070201.jpg"></center><br><center><u><font color="grey">why??</font></u></center><p>因为Array.prototype 虽然没这些方法，但是它有原型对象（<font color="purple"><strong>__</strong>proto__</font>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面我们说了 Object.prototype 就是一个普通对象。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></p><p>所以 <font color="purple">Array.prototype</font> 继承了对象的所有方法，当你用<font color="purple">num.hasOwnPrototype()</font>时，JS 会先查一下它的构造函数 （<font color="purple">Array</font>） 的原型对象 <font color="purple">Array.prototype</font> 有没有有<font color="purple">hasOwnPrototype()</font>方法，没查到的话继续查一下<font color="purple"> Array.prototype</font> 的原型对象 <font color="purple">Array.prototype.<strong>__</strong>proto__</font>有没有这个方法。</p><p><b>当我们创建一个函数时：</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>,<span class="string">"return x*x;"</span>);</span><br><span class="line"><span class="comment">//当然你也可以这么创建 f = function(x)&#123; return x*x &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.arguments) <span class="comment">// arguments 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(f.call(<span class="built_in">window</span>)) <span class="comment">// call 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype) <span class="comment">// function() &#123;&#125; （一个空的函数）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Function</span>.prototype)); </span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">["length", "name", "arguments", "caller", "constructor", "bind", "toString", "call", "apply"]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们再复习第八小节这句话：</p><pre><code>所有函数对象proto都指向 Function.prototype，它是一个空函数（Empty function）</code></pre><p>嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的函数对象都能用，比如:<br><br></p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070207.jpg"></center><br><center><u><font color="grey">函数对象</font></u></center><p>如果你还没搞懂啥是函数对象？</p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070203.jpg"></center><br><center><u><font color="grey"><br>去屎 | center</font></u></center><p>还有，我建议你可以再复习下为什么：</p><pre><code>Function.prototype 是唯一一个typeof XXX.prototype为 “function”的prototype</code></pre><p>我猜你肯定忘了。</p><h2 id="九-复习一下"><a href="#九-复习一下" class="headerlink" title="九. 复习一下"></a>九. 复习一下</h2><p>第八小节我们总结了：</p><pre><code>所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）</code></pre><p>但是你可别忘了在第三小节我们总结的：</p><pre><code>所有对象的 __proto__ 都指向其构造器的 prototype</code></pre><p>咦，我找了半天怎么没找到这句话……<br><br></p><center><img src="http://oo590vn4k.bkt.clouddn.com/2017070204.jpg"></center><br><center><u><font color="grey">doge | center</font></u></center><p>我们下面再复习下这句话。</p><p>先看看 JS 内置构造器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__ === <span class="built_in">RegExp</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__ === <span class="built_in">Error</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>再看看自定义的构造器，这里定义了一个 <font color="purple">Person</font>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><font color="purple">p</font> 是 <font color="purple">Person</font> 的实例对象，p 的内部原型总是指向其构造器 <font color="purple">Person</font> 的原型对象 <font color="purple">prototype</font>。</p><p>每个对象都有一个 <font color="purple">constructor</font> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面的<font color="purple">Person</font>没有给其原型添加属性或方法，这里给其原型添加一个<font color="purple">getName</font>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到<font color="purple">p.<strong>__</strong>proto__</font>与<font color="purple">Person.prototype，p.constructor.prototype</font>都是恒等的，即都指向同一个对象。</p><p>如果换一种方式设置原型，结果就有些不同了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>这里直接重写了 <font color="purple">Person.prototype</font>（注意：上一个示例是修改原型）。输出结果可以看出<font color="purple">p.<strong>__</strong>proto__</font>仍然指向的是<font color="purple">Person.prototype</font>，而不是<font color="purple">p.constructor.prototype</font>。</p><p>这也很好理解，给<font color="purple">Person.prototype</font>赋值的是一个对象直接量<font color="purple">{getName: function(){}}</font>，使用对象直接量方式定义的对象其构造器<font color="purple">（constructor）</font>指向的是根构造器<font color="purple">Object，Object.prototype</font>是一个空对象<font color="purple">{}</font>，<font color="purple">{}</font>自然与<font color="purple">{getName: function(){}}</font>不等。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype) <span class="comment">// 为一个空的对象&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor === <span class="built_in">Object</span>) <span class="comment">// 对象直接量方式定义的对象其constructor为Object</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor.prototype === <span class="built_in">Object</span>.prototype) <span class="comment">// 为true，不解释(๑ˇ3ˇ๑)</span></span><br></pre></td></tr></table></figure><h2 id="十-原型链（再复习一下：）"><a href="#十-原型链（再复习一下：）" class="headerlink" title="十. 原型链（再复习一下：）"></a>十. 原型链（再复习一下：）</h2><p>下面这个例子你应该能明白了！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ == <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype)<span class="comment">// function()&#123;&#125; (空函数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// [] (空数组)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>疑点解惑：</p><ol><li><p><font color="purple">Object.<strong>__</strong>proto______ === Function.prototype // true</font><br><font color="purple">Object</font> 是函数对象，是通过<font color="purple">new Function()</font>创建的，所以<font color="purple">Object.<strong>__</strong>proto____</font>指向<font color="purple">Function.prototype</font>。（参照第八小节：「所有函数对象的<font color="purple"><strong>proto</strong></font>都指向<font color="purple">Function.prototype</font>」）</p></li><li><p><font color="purple">Function.<strong>__</strong>proto____ === Function.prototype // true</font><br><font color="purple">Function</font> 也是对象函数，也是通过<font color="purple">new Function()</font>创建，所以<font color="purple">Function.<strong>__</strong>proto__</font>指向<font color="purple">Function.prototype</font>。</p><pre><code>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）正如《道德经》里所说“无，名天地之始”。</code></pre></li><li><p>Function.prototype.<strong>__</strong>proto__ === Object.prototype //true</p><pre><code>其实这一点我也有点困惑，不过也可以试着解释一下。Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.__proto__ === null，保证原型链能够正常结束。</code></pre></li></ol><h2 id="十一-总结"><a href="#十一-总结" class="headerlink" title="十一 总结"></a>十一 总结</h2><ul><li>原型和原型链是JS实现继承的一种模型。</li></ul><ul><li>原型链的形成是真正是靠<strong>__</strong>proto______ 而非prototype</li></ul><p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">animal.price = <span class="number">2000</span>;</span><br><span class="line">dog.prototype = animal;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog.price) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(tidy.price) <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure></p><p>这里解释一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">dog.prototype.price = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(tidy.price); <span class="comment">// 2000</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line">tidy.price = <span class="number">2000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>这个明白吧？想一想我们上面说过这句话：</p><pre><code>实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。</code></pre><p>聪明的你肯定想通了吧 ：）</p><hr><p>本文借鉴了：</p><ol><li><a href="http://www.108js.com/article/article1/10201.html?id=1092" target="_blank" rel="noopener">《JS原型与原型链终极详解》</a><br>作者：zhangjiahao8961</li><li><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="noopener">JavaScript中proto与prototype的关系</a><br>作者：snandy</li><li>《JavaScript 高级程序设计》中文译本 第三版</li></ol><p>作者：Yi罐可乐<br>链接：<a href="http://www.jianshu.com/p/a4e1e7b6f4f8" target="_blank" rel="noopener">http://www.jianshu.com/p/a4e1e7b6f4f8</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;七-函数对象-（复习一下前面的知识点）&quot;&gt;&lt;a href=&quot;#七-函数对象-（复习一下前面的知识点）&quot; class=&quot;headerlink&quot; title=&quot;七. 函数对象 （复习一下前面的知识点）&quot;&gt;&lt;/a&gt;七. 函数对象 （复习一下前面的知识点）&lt;/h2&gt;&lt;p&gt;&lt;b&gt;所有函数对象的&lt;strong&gt;proto&lt;/strong&gt;都指向Function.prototype，它是一个空函数（Empty function）&lt;/b&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Boolean&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Boolean&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype   &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype   &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype    &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.constructor == &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的&lt;b&gt;&lt;strong&gt;__&lt;/strong&gt;proto____&lt;/b&gt;是Object.prototype。如下&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.construrctor == &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.construrctor == &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面说的&lt;b&gt;函数对象&lt;/b&gt;当然包括自定义的。如下&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Perosn = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Person.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Man.__proto__ === &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype)    &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这说明什么呢？&lt;br&gt;
    
    </summary>
    
      <category term="二、原型和原型链" scheme="https://zhang-hongbin.github.io/categories/%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    
      <category term="原型" scheme="https://zhang-hongbin.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>六、DOM操作</title>
    <link href="https://zhang-hongbin.github.io/2017/07/01/%E5%85%AD%E3%80%81DOM%E6%93%8D%E4%BD%9C/"/>
    <id>https://zhang-hongbin.github.io/2017/07/01/六、DOM操作/</id>
    <published>2017-07-01T09:46:46.000Z</published>
    <updated>2017-08-31T08:05:18.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><ul><li>DOM本质<pre><code>DOM可以理解为：浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型而已。</code></pre></li><li><p>DOM节点操作</p><ol><li>获取 DOM 节点<pre><code>- document.getElementById()- document.getElementClassName()- document.getElementByTagName()</code></pre></li><li><p>property</p></li><li><p>Attribute</p></li></ol></li><li><p>DOM结构操作</p><ol><li><p>新增节点</p></li><li><p>获取父元素</p></li><li><p>获取子元素</p></li><li>删除节点</li></ol></li></ul><h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><pre><code>1. DOM是哪种基本的数据结构？    答：树2. DOM操作的常用API有哪些    答：    ⑴获取DOM节点，以及节点的property和Attribute        ⑵获取父节点，获取子节点        ⑶新增节点，删除节点3. DOM节点的Attribute 和 property 有何区别    答：property 只是一个JS对象属性的修改        Attribute 是对html标签属性的修改</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DOM本质&lt;pre&gt;&lt;code&gt;DOM可以理解为：浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操
      
    
    </summary>
    
      <category term="六、DOM操作" scheme="https://zhang-hongbin.github.io/categories/%E5%85%AD%E3%80%81DOM%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="DOM" scheme="https://zhang-hongbin.github.io/tags/DOM/"/>
    
      <category term="getElementById" scheme="https://zhang-hongbin.github.io/tags/getElementById/"/>
    
      <category term="Attribute" scheme="https://zhang-hongbin.github.io/tags/Attribute/"/>
    
      <category term="property" scheme="https://zhang-hongbin.github.io/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</title>
    <link href="https://zhang-hongbin.github.io/2017/07/01/%E6%9C%80%E8%AF%A6%E5%B0%BD%E7%9A%84-JS-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%88%E6%9E%81%E8%AF%A6%E8%A7%A3%EF%BC%8C%E6%B2%A1%E6%9C%89%E3%80%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E3%80%8D%E3%80%82%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zhang-hongbin.github.io/2017/07/01/最详尽的-JS-原型与原型链终极详解，没有「可能是」。（二）/</id>
    <published>2017-07-01T04:33:12.000Z</published>
    <updated>2017-09-02T11:01:30.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四-proto"><a href="#四-proto" class="headerlink" title="四. __proto__"></a>四. <strong>__</strong>proto__</h2><p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<font color="purple"><strong>__</strong>proto______</font> 的内置属性，用于指向创建它的构造函数的原型对象。<br>对象 person1 有一个<font color="purple"> <strong>__</strong>proto__</font>属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ == Person.prototype</span><br></pre></td></tr></table></figure></p><p>请看下图：<br><img src="http://oo590vn4k.bkt.clouddn.com/2017070101.jpg"></p><center><u>《JavaScript 高级程序设计》的图 6-1 </u></center><br>根据上面这个连接图，我们能得到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person;</span><br><span class="line">person1.__proto__ == Person.prototype;</span><br><span class="line">person1.constructor == Person;</span><br></pre></td></tr></table></figure><br><br><b>不过，要明确的真正重要的一点就是，这个连接存在于实例（<font color="purple">person1</font>）与构造函数（<font color="purple">Person</font>）的原型对象（<font color="purple">Person.prototype</font>）之间，而不是存在于实例（<font color="purple">person1</font>）与构造函数（<font color="purple">Person</font>）之间。</b><br><br>注意：因为绝大部分浏览器都支持<strong>proto</strong>属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。<br><br><a id="more"></a><br><br><h2> 五. 构造器 </h2><br><br>熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure><br><br>它等同于下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><br><br>obj 是构造函数（Object）的一个实例。所以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor === <span class="built_in">Object</span></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><br><br>新对象 obj 是使用 new 操作符后跟一个<b>构造函数</b>来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。<br><hr><br>同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。<br>所以我们也可以构造函数来创建 Array、 Date、Function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure><br><br>这些构造器都是函数对象：<br><img src="http://oo590vn4k.bkt.clouddn.com/2017070102.jpg"><br><br><center><u><font color="grey">函数对象</font></u></center><h2 id="六-原型链"><a href="#六-原型链" class="headerlink" title="六. 原型链"></a>六. 原型链</h2><p>小测试来检验一下你理解的怎么样：</p><font color="purple">person1.<strong>__</strong>proto______</font> 是什么？<br><font color="purple">Person.<strong>__</strong>proto______</font> 是什么？<br><font color="purple">Person.prototype.<strong>__</strong>proto______</font> 是什么？<br><font color="purple">Object.<strong>__</strong>proto______</font> 是什么？<br><font color="purple">Object.prototype______proto______</font> 是什么？<br>答案：<br>第一题：<br>因为 <font color="purple">person1.<strong>__</strong>proto______ === person1 的构造函数.prototype</font><br>因为 <font color="purple">person1的构造函数 === Person</font><br>所以 <font color="purple">person1.<strong>__</strong>proto______ === Person.prototype</font><p>第二题：<br>因为 <font color="purple">Person.<strong>__</strong>proto______ === Person的构造函数.prototype</font><br>因为 <font color="purple">Person的构造函数 === Function</font><br>所以 <font color="purple">Person.<strong>__</strong>proto______ === Function.prototype</font></p><p>第三题：</p><font color="purple">Person.prototype</font> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。<br>因为一个普通对象的构造函数 === Object<br>所以 <font color="purple">Person.prototype.<strong>__</strong>proto______ === Object.prototype</font><p>第四题，参照第二题，因为 Person 和 Object 一样都是构造函数</p><p>第五题：</p><font color="purple">Object.prototype</font> 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。<br><font color="purple">Object.prototype.<strong>__</strong>proto______ === null</font><p>好了，如果以上你都能明白，那就可以继续深入学习第三篇教程了：<br><a href="http://www.zhanghongbin.top/2017/07/02/%E6%9C%80%E8%AF%A6%E5%B0%BD%E7%9A%84-JS-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%88%E6%9E%81%E8%AF%A6%E8%A7%A3%EF%BC%8C%E6%B2%A1%E6%9C%89%E3%80%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E3%80%8D%E3%80%82%EF%BC%88%E4%B8%89%EF%BC%89/" target="_self">第三篇，点击进入</a></p><p>作者：Yi罐可乐<br>链接：<a href="http://www.jianshu.com/p/652991a67186" target="_blank" rel="noopener">http://www.jianshu.com/p/652991a67186</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四-proto&quot;&gt;&lt;a href=&quot;#四-proto&quot; class=&quot;headerlink&quot; title=&quot;四. __proto__&quot;&gt;&lt;/a&gt;四. &lt;strong&gt;__&lt;/strong&gt;proto__&lt;/h2&gt;&lt;p&gt;JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做&lt;font color=&quot;purple&quot;&gt;&lt;strong&gt;__&lt;/strong&gt;proto______&lt;/font&gt; 的内置属性，用于指向创建它的构造函数的原型对象。&lt;br&gt;对象 person1 有一个&lt;font color=&quot;purple&quot;&gt; &lt;strong&gt;__&lt;/strong&gt;proto__&lt;/font&gt;属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;person1.__proto__ == Person.prototype&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;请看下图：&lt;br&gt;&lt;img src=&quot;http://oo590vn4k.bkt.clouddn.com/2017070101.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;u&gt;《JavaScript 高级程序设计》的图 6-1 &lt;/u&gt;&lt;/center&gt;&lt;br&gt;根据上面这个连接图，我们能得到：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.constructor == Person;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.__proto__ == Person.prototype;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.constructor == Person;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;不过，要明确的真正重要的一点就是，这个连接存在于实例（&lt;font color=&quot;purple&quot;&gt;person1&lt;/font&gt;）与构造函数（&lt;font color=&quot;purple&quot;&gt;Person&lt;/font&gt;）的原型对象（&lt;font color=&quot;purple&quot;&gt;Person.prototype&lt;/font&gt;）之间，而不是存在于实例（&lt;font color=&quot;purple&quot;&gt;person1&lt;/font&gt;）与构造函数（&lt;font color=&quot;purple&quot;&gt;Person&lt;/font&gt;）之间。&lt;/b&gt;&lt;br&gt;&lt;br&gt;注意：因为绝大部分浏览器都支持&lt;strong&gt;proto&lt;/strong&gt;属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="二、原型和原型链" scheme="https://zhang-hongbin.github.io/categories/%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    
      <category term="原型" scheme="https://zhang-hongbin.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>原生JS forEach()和map()遍历的区别以及兼容写法</title>
    <link href="https://zhang-hongbin.github.io/2017/06/29/%E5%8E%9F%E7%94%9FJS-forEach-%E5%92%8Cmap-%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95/"/>
    <id>https://zhang-hongbin.github.io/2017/06/29/原生JS-forEach-和map-遍历的区别以及兼容写法/</id>
    <published>2017-06-29T12:46:46.000Z</published>
    <updated>2017-09-04T14:30:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、原生JS-forEach-和map-遍历"><a href="#一、原生JS-forEach-和map-遍历" class="headerlink" title="一、原生JS forEach()和map()遍历"></a>一、原生JS forEach()和map()遍历</h2><p>共同点：</p><pre><code>1.都是循环遍历数组中的每一项。2.forEach() 和 map() 里面每一次执行匿名函数都支持3个参数：数组中的当前项item,当前项的索引index,原始数组input。3.匿名函数中的this都是指Window。4.只能遍历数组。</code></pre><h3 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1.forEach()"></a>1.forEach()</h3><p>   没有返回值。</p><p>arr[].forEach(function(value,index,array){</p><p>　　//do something</p><p>})</p><p>参数：value数组中的当前项, index当前项的索引, array原始数组；<br>数组中有几项，那么传递进去的匿名回调函数就需要执行几次；<br>理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">42</span>,<span class="number">1</span>];  </span><br><span class="line"><span class="keyword">var</span> res = ary.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,input</span>) </span>&#123;  </span><br><span class="line">       input[index] = item*<span class="number">10</span>;  </span><br><span class="line">&#125;)  </span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//--&gt; undefined;  </span></span><br><span class="line"><span class="built_in">console</span>.log(ary);<span class="comment">//--&gt; 通过数组索引改变了原数组；</span></span><br></pre></td></tr></table></figure></p><h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map()"></a>2.map()</h3><p>有返回值，可以return 出来。</p><p>arr[].map(function(value,index,array){</p><p>　　//do something</p><p>　　return XXX</p><p>})</p><p>参数：value数组中的当前项,index当前项的索引,array原始数组；<br>区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">42</span>,<span class="number">1</span>];  </span><br><span class="line"><span class="keyword">var</span> res = ary.map(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,input</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">10</span>;  </span><br><span class="line">&#125;)  </span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//--&gt;[120,230,240,420,10];  原数组拷贝了一份，并进行了修改</span></span><br><span class="line"><span class="built_in">console</span>.log(ary);<span class="comment">//--&gt;[12,23,24,42,1]；  原数组并未发生变化</span></span><br></pre></td></tr></table></figure></p><p>兼容写法：</p><p>不管是forEach还是map在IE6-8下都不兼容（不兼容的情况下在Array.prototype上没有这两个方法）,那么需要我们自己封装一个都兼容的方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* forEach遍历数组 </span></span><br><span class="line"><span class="comment">* @param callback [function] 回调函数； </span></span><br><span class="line"><span class="comment">* @param context [object] 上下文； </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">callback,context</span>)</span>&#123;  </span><br><span class="line">    context = context || <span class="built_in">window</span>;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'forEach'</span> <span class="keyword">in</span> <span class="built_in">Array</span>.prototye) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.forEach(callback,context);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//IE6-8下自己编写回调函数执行的逻辑  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = <span class="keyword">this</span>.length; i &lt; len;i++) &#123;  </span><br><span class="line">        callback &amp;&amp; callback.call(context,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* map遍历数组 </span></span><br><span class="line"><span class="comment">* @param callback [function] 回调函数； </span></span><br><span class="line"><span class="comment">* @param context [object] 上下文； </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> <span class="title">myMap</span>(<span class="params">callback,context</span>)</span>&#123;  </span><br><span class="line">    context = context || <span class="built_in">window</span>;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'map'</span> <span class="keyword">in</span> <span class="built_in">Array</span>.prototye) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map(callback,context);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//IE6-8下自己编写回调函数执行的逻辑  </span></span><br><span class="line">    <span class="keyword">var</span> newAry = [];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = <span class="keyword">this</span>.length; i &lt; len;i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span>  callback === <span class="string">'function'</span>) &#123;  </span><br><span class="line">            <span class="keyword">var</span> val = callback.call(context,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>);  </span><br><span class="line">            newAry[newAry.length] = val;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> newAry;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 二、jQuery $.each()和$.map()遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">共同点：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">即可遍历数组，又可遍历对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1.$.each()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">没有返回值。$.each()里面的匿名函数支持2个参数：当前项的索引i，数组中的当前项v。如果遍历的是对象，k 是键，v 是值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$.each(arr, function(index,value)&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　//do something</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">参数：arr要遍历的数组,index当前项的索引,value数组中的当前项</span></span><br><span class="line"><span class="string">第1个和第2个参数正好和以上两个函数是相反的，注意不要记错了</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">$.each( [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">i, v</span>)</span>&#123;  </span><br><span class="line">     alert( i + <span class="string">": "</span> + v );  </span><br><span class="line">&#125;);  </span><br><span class="line">[javascript] view plain copy</span><br><span class="line"> </span><br><span class="line">$(<span class="string">"span"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i, v</span>)</span>&#123;  </span><br><span class="line">     alert( i + <span class="string">": "</span> + v );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.each( &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">lang</span>: <span class="string">"JS"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">k, v</span>)</span>&#123;  </span><br><span class="line">     alert( <span class="string">"Name: "</span> + k + <span class="string">", Value: "</span> + v );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-map-1"><a href="#2-map-1" class="headerlink" title="2.$.map()"></a>2.$.map()</h3><p>有返回值，可以return 出来。$.map()里面的匿名函数支持2个参数和$.each()里的参数位置相反：数组中的当前项v，当前项的索引 i。如果遍历的是对象，k 是键，v 是值。如果是$(“span”).map()形式，参数顺序和$.each()  $(“span”).each()一样。</p><p>$.map(arr, function(value, index){</p><p>　　//do something</p><p>　　return XXX</p><p>})</p><pre><code class="javascript">    <span class="keyword">var</span> arr=$.map( [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>{           <span class="keyword">return</span> v + <span class="number">4</span>;      });      <span class="built_in">console</span>.log(arr);      [javascript] view plain copy    $.map({<span class="string">"name"</span>:<span class="string">"Jim"</span>,<span class="string">"age"</span>:<span class="number">17</span>},<span class="function"><span class="keyword">function</span>(<span class="params">k, v</span>)</span>{           <span class="built_in">console</span>.log( k+<span class="string">":"</span>+v );  });</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、原生JS-forEach-和map-遍历&quot;&gt;&lt;a href=&quot;#一、原生JS-forEach-和map-遍历&quot; class=&quot;headerlink&quot; title=&quot;一、原生JS forEach()和map()遍历&quot;&gt;&lt;/a&gt;一、原生JS forEach()和m
      
    
    </summary>
    
      <category term="五、其他知识" scheme="https://zhang-hongbin.github.io/categories/%E4%BA%94%E3%80%81%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="forEach" scheme="https://zhang-hongbin.github.io/tags/forEach/"/>
    
      <category term="map" scheme="https://zhang-hongbin.github.io/tags/map/"/>
    
  </entry>
  
</feed>
