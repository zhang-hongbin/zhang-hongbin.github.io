<!doctype html>



  

<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="ZHB-CSDN" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="ZHB-CSDN">
<meta property="og:url" content="https://zhang-hongbin.github.io/page/9/index.html">
<meta property="og:site_name" content="ZHB-CSDN">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZHB-CSDN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhang-hongbin.github.io/page/9/"/>





  <title> ZHB-CSDN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZHB-CSDN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Be here now</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            檔案
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標簽
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhang-hongbin.github.io/2017/04/05/HTTP协议：缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Hongbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo590vn4k.bkt.clouddn.com/111.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHB-CSDN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/HTTP协议：缓存/" itemprop="url">
                  HTTP协议：缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T17:35:51+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/九、Ajax/" itemprop="url" rel="index">
                    <span itemprop="name">九、Ajax</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP协议：缓存"><a href="#HTTP协议：缓存" class="headerlink" title="HTTP协议：缓存"></a>HTTP协议：缓存</h1><h3 id="1-缓存的优点"><a href="#1-缓存的优点" class="headerlink" title="1.缓存的优点"></a>1.缓存的优点</h3><ol>
<li><em>缓存减少了冗余的数据传输，节省了网络费用。</em></li>
<li><em>缓存缓解了网络瓶颈的问题，不需要更多的网络带宽就能更快的加载页面。</em> </li>
<li><em>缓存降低了对原始服务器的要求，服务器可以更快的响应。</em></li>
</ol>
<h3 id="2-缓存分类"><a href="#2-缓存分类" class="headerlink" title="2.缓存分类"></a>2.缓存分类</h3><h4 id="1-私有缓存"><a href="#1-私有缓存" class="headerlink" title="1)私有缓存"></a>1)私有缓存</h4><p>　　 常见就是我们的浏览器里内置的缓存。</p>
<h4 id="2）公有缓存"><a href="#2）公有缓存" class="headerlink" title="2）公有缓存"></a>2）公有缓存</h4><p>　　常见的就是代理缓存，不多介绍。</p>
<h3 id="3-缓存的处理流程"><a href="#3-缓存的处理流程" class="headerlink" title="3.缓存的处理流程"></a>3.缓存的处理流程</h3><p><img src="http://oo590vn4k.bkt.clouddn.com/12-1.png" alt=""><br>处理流程图，如上所示，下面分步骤具体介绍：<br>　　1）请求处理<br>　　用户发起一个http请求，缓存获取到URL，根据URL查找是否有匹配的副本，这个副本可能在内存中，也可能在本地磁盘。<br>　　2） 新鲜度检测<br>　　如果缓存中存在所请求资源的副本，则进行新鲜度检测。新鲜度检测举个简单的例子，我们在商店买了一瓶汽水，汽水瓶上肯定会标有过期时间，我们会根据这个过期时间和现在的时间做对比，看看饮料过期了没，如果没过期，我们正常喝就行了，如果已经过期，我们肯定要找商家。。。其实这就是一个新鲜度检测的过程，HTTP请求的新鲜度检测流程也是这样的，HTTP发起一个请求时，发现缓存中有相应的副本，接着就会检查这个副本有没有过期，如果没有过期，直接使用。如果已经过期，则进行再验证。具体的实现在下面会介绍。<br>　　3）服务器再验证<br>　　缓存中的文档过期了并不代表他和服务器上的不一样，所以这个时候就需要问问服务器，过期的这段时间里这个文档到底有没有改变。如果改变了，缓存就会获取一份新的文档副本，然后发送给客户端。如果没有改变，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部更新。<br>　　4）创建响应并返回<br>　　我们希望缓存看起来就像是来自原始服务器一样，缓存将已缓存的服务器响应首部作为响应首部，发送给客户端。</p>
<p>###4.保质期的实现<br>　　HTTP中，通过Cache-Control首部和Expires首部为文档指定了过期时间，通过对过期时间的判断，缓存就可以知道文档是不是在保质期内。Expires首部和Cache-Control:max-age首部都是来告诉缓存文档有没有过期，为什么需要两个响应首部来做这件简单的事情了？其实这一切都是历史原因，Expires首部是HTTP 1.0中提出来的，因为他使用的是绝对日期，如果服务端和客户端时钟不同步的话（实际上这种情况非常常见），缓存可能就会认为文档已经过了保质期。<br>　　HTTP 1.1为了修正这个问题，引入了Cache-Control:max-age首部，这个首部使用相对时间来控制保质期，让一切变得更加合理。举个例子，我们买了一瓶汽水，如果使用Expires首部来标注保质期，就会这么写：饮料过期时间：2012年12月21日，如果某个2货不知道今天多少号，他还真不知道这饮料过期没，我小时候饮料都这么写。后来，有个挺有名的卖牛奶的，大概就叫蒙牛，他发明了一种标注保质期的方法，他怎么搞了？他这么写：保质期：12个月，行，牛逼了，我牛奶一年前就生产出来的牛奶，今天要发给厂家，发之前，先往包装上印上生产日期（当然是印发货那天），然后告诉你，明年才过期，这多聪明，搞成相对的，毒死你。也许HTTP 1.1借鉴了这个伟大的发明，于是就有了Cache-Control:max-age首部。</p>
<h3 id="5-服务器再验证的实现"><a href="#5-服务器再验证的实现" class="headerlink" title="5.服务器再验证的实现"></a>5.服务器再验证的实现</h3><p>　　缓存要问问服务器，牛奶已经过期了，到底还能不能喝。我说错了，是文档，不是牛奶。HTTP中，使用两个请求请首部来完成这个功能：If-Modified-Sice和If-None-Match。为啥又要两个首部来完成这个功能了？答案还是因为历史的原因。一开始使用 If-Modified-Sice:<date>首部，date是上一次缓存牛奶时，响应中Last-Modified首部的值。<br>　　客户端拿着这个值，问服务器，这段时间内这个牛奶你有没有修改过？服务器看了看这个牛奶的修改时间，如果没有修改过，会返回一个304 Not Modified的响应；如果修改过，把最新的牛奶返回给客户端。后来，人们发现这样有问题，因为就算修改时间变化了，文档也不一定发生改变！于是乎，就有了 If-None-Match:<tag>首部，tag是上一次缓存文档时，响应中Etag的值，Etag是一种唯一标识资源的方式，就像java中的hashcode，如果hashcode不一样，那么两个对象肯定不一样！</tag></date></p>
<h3 id="6-试探性过期"><a href="#6-试探性过期" class="headerlink" title="6.试探性过期"></a>6.试探性过期</h3><p>　　如果响应中既没有Cache-Control:max-age首部又没有Expires首部，缓存可以计算出一个试探性最大使用期。这东西打个比方就是缓存会根据响应的Last-Modified来决定这文档靠不靠谱，需不需要再验证，如果Last-Modified中的日期是很早之前，那缓存就认为这文档挺靠谱，近期之内应该不会变化；如果Last-Modified中的日期是最近几天，那缓存可能就认为这文档可能经常改变，不靠谱。当然这么粗略的判断想想就知道不严谨，所以我们一定要设置Expires首部和Cache-Control首部。</p>
<h3 id="7-写在最后"><a href="#7-写在最后" class="headerlink" title="7.写在最后"></a>7.写在最后</h3><p>　　如果你是个好学者，看完这个文章，你可能会迫不及待的打开你的chrome浏览器，F12，观察oschina的HTTP信息。这个时候的你，肯定和几个月前的我一样茫然，因为你发现我上面讲的很多东西再这里被现实无情推翻了。看看这个讨论记录，这是几个月前我在OSC上问的。之所以会出现这个情况，是因为chrome为了保证牛奶的安全放心，所以他不太信任包装上的保质期标识，每次都问问服务器（再验证），牛奶有没有变化，没变化的话他就直接喝了！一切都是为了安全！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhang-hongbin.github.io/2017/03/11/LibSVM学习详细说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Hongbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo590vn4k.bkt.clouddn.com/111.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHB-CSDN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/LibSVM学习详细说明/" itemprop="url">
                  LibSVM学习详细说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T13:36:46+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码文件主要针对Matlab进行说明,但个人仍觉得讲解的支持向量机内容非常棒,可以做为理解这一统计方法的辅助资料;</p>
<p> LibSVM是台湾林智仁(Chih-Jen Lin)教授2001年开发的一套支持向量机的库，这套库运算速度还是挺快的，可以很方便的对数据做分类或回归。由于libSVM程序小，运用灵活，输入参数少，并且是开源的，易于扩展，因此成为目前国内应用最多的SVM的库。</p>
<p>这套库可以从<a href="http://www.csie.ntu.edu.tw/~cjlin/免费获得，目前已经发展到2.89版。下载.zip格式的版本，解压后可以看到，主要有5个文件夹和一些c++源码文件。" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/免费获得，目前已经发展到2.89版。下载.zip格式的版本，解压后可以看到，主要有5个文件夹和一些c++源码文件。</a></p>
<p>Java——主要是应用于java平台；</p>
<p>Python——是用来参数优选的工具，稍后介绍；</p>
<p>svm-toy——一个可视化的工具，用来展示训练数据和分类界面，里面是源码，其编译后的程序在windows文件夹下；</p>
<p>tools——主要包含四个python文件，用来数据集抽样(subset)，参数优选（grid），集成测试(easy),数据检查(checkdata)；</p>
<p>windows——包含libSVM四个exe程序包，我们所用的库就是他们，里面还有个heart_scale，是一个样本文件，可以用记事本打开，用来测试用的。</p>
<p>其他.h和.cpp文件都是程序的源码，可以编译出相应的.exe文件。其中，最重要的是svm.h和svm.cpp文件，svm-predict.c、svm-scale.c和svm-train.c（还有一个svm-toy.c在svm-toy文件夹中）都是调用的这个文件中的接口函数，编译后就是windows下相应的四个exe程序。另外，里面的 README 跟 FAQ也是很好的文件，对于初学者如果E文过得去，可以看一下。</p>
<p>下面以svm-train为例，简单的介绍下，怎么编译：（这步很简单，也没必要，对于仅仅使用libsvm库的人来说，windows下的4个exe包已经足够了，之所以加这步，是为了那些做深入研究的人，可以按照自己的思路改变一下svm.cpp，然后编译验证）</p>
<p>我用的是VC 6.0，新建一个控制台（win32 console application）程序，程序名叫svm-train（这个可以随意），点击OK后，选择empty。</p>
<p>进入程序框架后，里面什么都没有，然后找到你的程序目录，把svm-train.c、svm.h和svm.cpp拷贝过去（.c文件是C语言的，要是你习惯了c++，你尽可以改成.cpp），然后把这3个文件添加到工程，编译。。。如果没错误，到debug下面看看，是不是有个svm-train.exe。其实windows下的svm-train.exe就是这样编译出来的。</p>
<p>哈哈，怎么样是不是很简单。但是，这样的程序直接运行没意义，他要在dos下运行，接收参数才行。下面开始我们的libsvm的体验之旅。</p>
<h2 id="第一次体验LibSvm"><a href="#第一次体验LibSvm" class="headerlink" title="第一次体验LibSvm"></a>第一次体验LibSvm</h2><ol>
<li><p>把LibSVM包解压到相应的目录（因为我只需要里面windows文件夹中的东东，我们也可以只把windows文件夹拷到相应的目录），比如D:/libsvm。</p>
</li>
<li><p>在电脑“开始”的“运行”中输入cmd，进入DOS环境。定位到d:/ libsvm下，具体命令如下:</p>
<p>d: (回车)</p>
<p>cd /libsvm/windows (回车)</p>
<p>(上面第一行是先定位到盘符d，第二行cd是定位到相应盘符下的目录)</p>
</li>
<li><p>进行libsvm训练，输入命令：(这里要注意文件的名字，2.89以前版本都是svmtrain.exe)</p>
<p>svm-train heart_scale train.model</p>
<p>heart_scale——是目录下的已经存在的样本文件，要换成自己的文件，只需改成自己的文件名就可以了</p>
<p>train.model——是创建的结果文件，保存了训练后的结果</p>
</li>
</ol>
<p>可以看到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optimization finished, #iter = 162</span><br><span class="line"></span><br><span class="line">nu = 0.431029</span><br><span class="line"></span><br><span class="line">obj = -100.877288, rho = 0.424462</span><br><span class="line"></span><br><span class="line">nSV = 132, nBSV = 107</span><br><span class="line"></span><br><span class="line">      Total nSV = 132</span><br></pre></td></tr></table></figure>
<p>其中，#iter为迭代次数，nu是你选择的核函数类型的参数，obj为SVM文件转换为的二次规划求解得到的最小值，rho为判决函数的偏置项b，nSV为标准支持向量个数(0&lt;a[i]&lt;c)，nBSV为边界上的支持向量个数(a[i]=c)，Total nSV为支持向量总个数（对于两类来说，因为只有一个分类模型Total nSV = nSV，但是对于多类，这个是各个分类模型的nSV之和）。</p>
<p>在目录下，还可以看到产生了一个train.model文件，可以用记事本打开，记录了训练后的结果。</p>
<p>svm_type c_svc<font color="green">//所选择的svm类型，默认为c_svc</font></p>
<p>kernel_type rbf<font color="green">//训练采用的核函数类型，此处为RBF核</font></p>
<p>gamma 0.0769231<font color="green">//RBF核的参数γ</font></p>
<p>nr_class 2<font color="green">//类别数，此处为两分类问题</font></p>
<p>total_sv 132<font color="green">//支持向量总个数</font></p>
<p>rho 0.424462<font color="green">//判决函数的偏置项b</font></p>
<p>label 1 -1<font color="green">//原始文件中的类别标识</font></p>
<p>nr_sv 64 68<font color="green">//每个类的支持向量机的个数</font></p>
<p>SV<font color="green">//以下为各个类的权系数及相应的支持向量</font></p>
<p>1 1:0.166667 2:1 3:-0.333333 … 10:-0.903226 11:-1 12:-1 13:1</p>
<p>0.5104832128985164 1:0.125 2:1 3:0.333333 … 10:-0.806452 12:-0.333333 13:0.5</p>
<p>………..</p>
<p>-1 1:-0.375 2:1 3:-0.333333…. 10:-1 11:-1 12:-1 13:1</p>
<p>-1 1:0.166667 2:1 3:1 …. 10:-0.870968 12:-1 13:0.5</p>
<p>到现在，第一次体验libsvm到这就基本结束了，其他的两个(svm-predict、svm-scale)的使用过程类似。怎么样，挺爽的吧。对于个别参数你还不理解，没关系，下面我们会具体讲到。</p>
<h2 id="LibSvm使用规范"><a href="#LibSvm使用规范" class="headerlink" title="LibSvm使用规范:"></a>LibSvm使用规范:</h2><p>其实，这部分写也是多余，google一下“libsvm使用”，就会N多的资源，但是，为了让你少费点心，在这里就简单的介绍一下，有不清楚的只有动动你的mouse了。需要说明的是，2.89版本以前，都是svmscale、svmtrain和svmpredict，最新的是svm-scale、svm-train和svm-predict，要是用不习惯，只需要把那四个exe文件名去掉中间的短横线，改成svmscale、svmtrain和svmpredict就可以了，我们还是按原来函数名的讲。</p>
<ol>
<li>libSVM的数据格式</li>
</ol>
<p>Label 1:value 2:value ….</p>
<p>Label：是类别的标识，比如上节train.model中提到的1 -1，你可以自己随意定，比如-10，0，15。当然，如果是回归，这是目标值，就要实事求是了。</p>
<p>Value：就是要训练的数据，从分类的角度来说就是特征值，数据之间用空格隔开</p>
<p>比如: -15 1:0.708 2:1056 3:-0.3333</p>
<p>需要注意的是，如果特征值为0，特征冒号前面的(姑且称做序号)可以不连续。如：</p>
<p>-15 1:0.708 3:-0.3333</p>
<p>表明第2个特征值为0，从编程的角度来说，这样做可以减少内存的使用，并提高做矩阵内积时的运算速度。我们平时在matlab中产生的数据都是没有序号的常规矩阵，所以为了方便最好编一个程序进行转化。</p>
<ol start="2">
<li>svmscale的用法</li>
</ol>
<p>svmscale是用来对原始样本进行缩放的，范围可以自己定，一般是[0,1]或[-1,1]。缩放的目的主要是</p>
<p>1）防止某个特征过大或过小，从而在训练中起的作用不平衡；</p>
<p>2）为了计算速度。因为在核计算中，会用到内积运算或exp运算，不平衡的数据可能造成计算困难。</p>
<p>用法：svmscale [-l lower] [-u upper]</p>
<p>[-y y_lower y_upper]</p>
<p>[-s save_filename]</p>
<p>[-r restore_filename] filename</p>
<p>其中，[]中都是可选项：</p>
<p> -l：设定数据下限；lower：设定的数据下限值，缺省为-1</p>
<p> -u：设定数据上限；upper：设定的数据上限值，缺省为 1</p>
<p> -y：是否对目标值同时进行缩放；y_lower为下限值，y_upper为上限值；</p>
<p> -s save_filename：表示将缩放的规则保存为文件save_filename；</p>
<p> -r restore_filename：表示将按照已经存在的规则文件restore_filename进行缩放；</p>
<p>  filename：待缩放的数据文件，文件格式按照libsvm格式。</p>
<p>默认情况下，只需要输入要缩放的文件名就可以了：比如(已经存在的文件为test.txt)</p>
<p>svmscale test.txt</p>
<p>这时，test.txt中的数据已经变成[-1,1]之间的数据了。但是，这样原来的数据就被覆盖了，为了让规划好的数据另存为其他的文件，我们用一个dos的重定向符 &gt; 来另存为(假设为out.txt)：</p>
<pre><code>svmscale test.txt &gt; out.txt
</code></pre><p>运行后，我们就可以看到目录下多了一个out.txt文件，那就是规范后的数据。假如，我们想设定数据范围[0,1]，并把规则保存为test.range文件:</p>
<pre><code>svmscale –l 0 –u 1 –s test.range test.txt &gt; out.txt
</code></pre><p>这时，目录下又多了一个test.range文件，可以用记事本打开，下次就可以用-r test.range来载入了。</p>
<ol start="3">
<li>svmtrain的用法</li>
</ol>
<p>svmtrain我们在前面已经接触过，他主要实现对训练数据集的训练，并可以获得SVM模型。</p>
<p>用法： svmtrain [options] training_set_file [model_file]</p>
<p>其中，options为操作参数，可用的选项即表示的涵义如下所示:</p>
<p>-s设置svm类型：</p>
<p>0 – C-SVC</p>
<p>1 – v-SVC</p>
<p>2 – one-class-SVM</p>
<p>3 –ε-SVR</p>
<p>4 – n - SVR</p>
<p>-t设置核函数类型，默认值为2</p>
<p>0 –线性核：u’*v</p>
<p>1 –多项式核：(g<em>u’</em>v+coef0)degree</p>
<p>2 – RBF核：exp(-γ*||u-v||2)</p>
<p>3 – sigmoid核：tanh(γ<em>u’</em>v+coef0)</p>
<p>-d degree:设置多项式核中degree的值，默认为3</p>
<p>-gγ:设置核函数中γ的值，默认为1/k，k为特征（或者说是属性）数；</p>
<p>-r coef 0:设置核函数中的coef 0，默认值为0；</p>
<p>-c cost：设置C-SVC、ε-SVR、n - SVR中从惩罚系数C，默认值为1；</p>
<p>-n v：设置v-SVC、one-class-SVM与n - SVR中参数n，默认值0.5；</p>
<p>-pε：设置v-SVR的损失函数中的e，默认值为0.1；</p>
<p>-m cachesize：设置cache内存大小，以MB为单位，默认值为40；</p>
<p>-eε：设置终止准则中的可容忍偏差，默认值为0.001；</p>
<p>-h shrinking：是否使用启发式，可选值为0或1，默认值为1；</p>
<p>-b概率估计：是否计算SVC或SVR的概率估计，可选值0或1，默认0；</p>
<p>-wi weight：对各类样本的惩罚系数C加权，默认值为1；</p>
<p>-v n：n折交叉验证模式；</p>
<p>model_file：可选项，为要保存的结果文件，称为模型文件，以便在预测时使用。</p>
<p>默认情况下，只需要给函数提供一个样本文件名就可以了，但为了能保存结果，还是要提供一个结果文件名，比如:test.model,则命令为：</p>
<p>svmtrain test.txt test.model</p>
<p>结果说明见LibSVM学习（二）.</p>
<ol start="4">
<li>svmpredict的用法</li>
</ol>
<p>svmpredict是根据训练获得的模型，对数据集合进行预测。</p>
<p>用法：svmpredict [options] test_file model_file output_file</p>
<p>其中，options为操作参数，可用的选项即表示的涵义如下所示:</p>
<p>-b probability_estimates——是否需要进行概率估计预测，可选值为0或者1，默认值为0。</p>
<p>model_file ——是由svmtrain产生的模型文件；</p>
<p>test_file——是要进行预测的数据文件，格式也要符合libsvm格式，<font color="red">即使不知道label的值，也要任意填一个，</font>svmpredict会在output_file中给出正确的label结果，如果知道label的值，就会输出正确率；</p>
<p>output_file ——是svmpredict的输出文件，表示预测的结果值。</p>
<p>至此，主要的几个接口已经讲完了，满足一般的应用不成问题。对于要做研究的，还需要深入到svm.cpp文件内部，看看都做了什么。</p>
<h2 id="逐步深入LibSVM-个人认为最精彩部分"><a href="#逐步深入LibSVM-个人认为最精彩部分" class="headerlink" title="逐步深入LibSVM(个人认为最精彩部分)"></a><font color="red">逐步深入LibSVM(个人认为最精彩部分)</font></h2><p>其实，在之前上海交大模式分析与机器智能实验室对2.6版本的svm.cpp做了部分注解，（在哪里？google一下你就知道）。但是，这个注释只是针对代码而注释，整篇看下来，你会发现除了理解几个参数的含义，还是会对libsvm一头雾水。当然作为理解程序的辅助材料，还是有很大用处的。特别是，对几个结构体的说明，比较清楚。但是要清楚程序具体做了什么，还是要追踪程序中去。</p>
<p>由于svm涉及的数学知识比较多，我们这篇只是讲一些基本的思路，所以就从最基本的C-SVC型svm，核函数采用常用的RBF函数。LibSVM就采用2.6版本的好了，因为后续的版本作者又加了很多内容，不易理解作者最初的思路。我是做模式识别，主要从分类的角度来解析函数的调用过程，我们从svmtrain.c看起，其调用的函数过程如下:4.1</p>
<p>   4.2</p>
<p>上图是整个C-SVC的计算过程，下面对一些重要的内容进行具体说明:</p>
<p>1.svm_group_class</p>
<p>在2.6版中没有此函数的，其功能直接在svm_train实现，为了增强可读性，2.89版中设置了这个函数，其实所作的工作都是一样的。需要说明的是其重新排列后perm中只存储的是各个样本在原始位置的序号，而非数据。这样做的好处有两个：</p>
<p> 1）不必破坏原始数据（也就是读进来的x的数据）；</p>
<p> 2）检索起来方便，只需要L维的数据检索，得到序号后，然后定位到原始数据中相应的位置就可以。</p>
<pre><code>4.3
</code></pre><p> perm是中各类的排列顺序是按照原始样本中各类出现的先后顺序排列的，不一定是按照你原始样本的label序号排列，假如原始样本的label是{-1，0，1}，而最先出现的label为1的样本，那么perm中就把label为1的作为类0最先排列。而start中记录的是各类的起始序号，而这个序号是在perm中的序号。</p>
<p>2.多类判别的one-against-one</p>
<p> svm做判别是用的分界线(面)，两类之间只有一个分界线(面)，因此分类器也只有1种，要么是1类要么是2类。但是对于多类，分类方式就有多种。目前，存在的方法主要有：</p>
<p> 1）1-V-R方式</p>
<p>  对于k类问题，把其中某一类的n个训练样本视为一类，所有其他类别归为另一类，因此共有k个分类器。最后预测时，判别式使用竞争方式，也就是哪个类得票多就属于那个类。</p>
<p> 2）1-V-1方式</p>
<p> 也就是我们所说的one-against-one方式。这种方法把其中的任意两类构造一个分类器，共有(k-1)×k/2个分类器。最后预测也采用竞争方式。</p>
<p> 3）有向无环图（DAG-SVM）</p>
<p>  该方法在训练阶段采用1-V-1方式，而判别阶段采用一种两向有向无环图的方式。</p>
<p>  LibSVM采用的是1-V-1方式，因为这种方式思路简单，并且许多实践证实效果比1-V-R方式要好。 </p>
<pre><code>4.4   
</code></pre><p> 上图是一个5类1-V-1组合的示意图，红色是0类和其他类的组合，紫色是1类和剩余类的组合，绿色是2类与右端两类的组合，蓝色只有3和4的组合。因此，对于nr_class个类的组合方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	for(i = 0; i &lt; nr_class; i ++)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	for(j = i+1; i &lt; nr_class; j ++)     </span><br><span class="line"></span><br><span class="line">	&#123; 类 i –V – 类 j &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.hessian矩阵的内存处理        </p>
<p> 因为svm是基于结构风险最小的，因此在分类识别方式具有较传统的基于经验风险最小的方式有优势。但是svm也有一个致命的缺陷，因为要计算hessian矩阵Qij所耗的内存巨大，不利于实践中应用。目前，怎么减小内存的使用依旧是SVM的研究的课题。LibSVM对hessian矩阵处理的策略是定义了一个内存处理类Cache类，预先认为分配一定的内存，存储计算好的Qij，其序号的检索采用双向链表的方式，加快了检索速度。其最重要的函数为：</p>
<p> int Cache::get_data(const int index,Qfloat **data,int len)</p>
<p> //len 是 data 的长度，data为返回的内存首地址，index为Qij的行。</p>
<p> 每次都要查找链表中行为index的Qi，假如已经计算过了，就返回计算过的内存地址，并把储存首地址的链表节点插入到链表尾部。假如没计算过，就分配内存并进行计算，当剩余的内存不够时，就要回收链表头指向的内存。这里，可能有人会问，难道以前计算的就没有用了吗？？其实，是因为Qij是稀疏矩阵，在训练过程中只要其对应的alpha[i]不再变动（这时alpha[i]=0或者alpha[i]=C），其对应的Qi就不会被选到来训练，因此原来计算的Qi就没有用了。其实，链表的顺序代表了别选到的频率，最头部的是最不可能被选到，因为这时alpha[i]=0或者alpha[i]=C，而最尾部的最容易被选到。</p>
<p>4.数据选择select_working_set(i,j)     </p>
<p> 对于样本数量比较多的时候（几千个），SVM所需要的内存是计算机所不能承受的。目前，对于这个问题的解决方法主要有两种：块算法和分解算法。这里，libSVM采用的是分解算法中的SMO(串行最小化)方法，其每次训练都只选择两个样本。我们不对SMO做具体的讨论，要想深入了解可以查阅相关的资料，这里只谈谈和程序有关的知识。</p>
<p> 一般SVM的对偶问题为：                      </p>
<pre><code>4.5              (4.1)                                                              
</code></pre><p>S.t.        </p>
<pre><code>4.6                                                                                          
</code></pre><p>SVM收敛的充分必要条件是KKT条件，其中:</p>
<pre><code>4.7           (4.2）
</code></pre><p>由4.1式求导可得：                          4.8       （4.3）</p>
<p>进一步推导可知：</p>
<pre><code>4.9                              （4.4）
</code></pre><p> 也就是说，只要所有的样本都满足4.4式，那么得到解就是最优值。因此，在每轮训练中，每次只要选择两个样本(序号为i和j)，是最违反KKT条件（也就是4.4式）的样本，就能保证其他样本也满足KKT条件。序号i和j的选择方式 :            4.10                         （4.5）</p>
<p>5.停止准则</p>
<p>LibSVM程序中，停止准则蕴含在了函数select_working_set(i,j)返回值中。也就是，当找不到符合4.5式的样本时，那么理论上就达到了最优解。但是，实际编程时，由于KKT条件还是蛮苛刻的，要进行适当的放松。令：</p>
<p>  4.11                                 （4.6）</p>
<p> 由4.4式可知，当所有样本都满足KKT条件时，gi ≤ -gj</p>
<p>加一个适当的宽松范围ε，也就是程序中的eps，默认为0.001，那么最终的停止准则为：</p>
<p>   gi ≤ -gj+ε  →    gi + gj≤ε                                    （4.7）</p>
<p>6.因子α的更新</p>
<p> 由于SMO每次都只选择2个样本，那么4.1式的等式约束可以转化为直线约束：</p>
<p> 4.12                                             （4.8）</p>
<p>   转化为图形表示为：</p>
<p>  4.13                            </p>
<p> 把4.8式中α1由α2 表示，即：4.14，结合上图由解析几何可得α2的取值范围：</p>
<p> 4.15           （4.9）</p>
<p>经过一系列变换，可以得到的α2更新值α2new：</p>
<p>  4.16                                               （4.10）</p>
<p>结合4.9和4.10式得到α2new最终表达式：</p>
<p> 4.17                                                            （4.11）</p>
<p>得到α2new后，就可以由4.8式求α1new。</p>
<p>这里，具体操作的时候，把选择后的序号i和j代替这里的1和2就可以了。当然，编程时，这些公式还是太抽象。对于4.9式，还需要具体细分。比如，对于y1 y2 = -1时的L = max(0,α2 - α1)，是0大还α2 - α1是大的问题。总共需要分8种情况。</p>
<p>7.数据缩放do_shrinking()</p>
<p>上面说到SVM用到的内存巨大，另一个缺陷就是计算速度，因为数据大了，计算量也就大，很显然计算速度就会下降。因此，一个好的方式就是在计算过程中逐步去掉不参与计算的数据。因为，实践证明，在训练过程中，alpha[i]一旦达到边界（alpha[i]=0或者alpha[i]=C），alpha[i]值就不会变，随着训练的进行，参与运算的样本会越来越少，SVM最终结果的支持向量（0&lt;alpha[i]&lt;C）往往占很少部分。</p>
<p>LibSVM采用的策略是在计算过程中，检测active_size中的alpha[i]值，如果alpha[i]到了边界，那么就应该把相应的样本去掉（变成inactived），并放到栈的尾部，从而逐步缩小active_size的大小。</p>
<ol start="8">
<li>截距b的计算</li>
</ol>
<p>b计算的基本公式为：</p>
<p>4.18                                                                       （4.12）</p>
<p> 理论上，b的值是不定的。当程序达到最优后，只要用任意一个标准支持向量机（0&lt;alpha[i]&lt;C）的样本带入4.12式，得到的b值都是可以的。目前，求b的方法也有很多种。在libSVM中，分别对y=+1和y=-1的两类所有支持向量求b，然后取平均值：</p>
<p>4.19                                                                     （4.13）</p>
<p>至此，libSVM的整个思路我们简单的过了一遍，里面涉及到很到理论知识，许多细节需要查看相关的SVM的书籍。说实话，笔者也是新手，有些理论也没弄很清楚，我只能把我知道的尽量的讲出来。希望对一些想要了解SVM的有所帮助。</p>
<p>分界线的输出</p>
<p>对于学习SVM人来说，要判断SVM效果，以图形的方式输出的分解线是最直观的。LibSVM自带了一个可视化的程序svm-toy，用来输出类之间的分界线。他是先把样本文件载入，然后进行训练，通过对每个像素点的坐标进行判断，看属于哪一类，就附上那类的颜色，从而使类与类之间形成分割线。我们这一节不讨论svm-toy怎么使用，因为这个是“傻瓜”式的，没什么好讨论的。这一节我们主要探讨怎么结合训练结果文件，自己编程输出分界线。</p>
<p>为什么说是分界线呢，其实严格说来是分解超平面，但是我们为了能直观用绘图工具绘(比如matlab)出图来只能输出具有二维（也就是特征数是2）的样本分界，因此也就成了线了。好了，闲话少说，进入正题。要绘分界线，就要用到训练结果，我们在第二节和第三节都讨论了，训练结果（或训练模型）文件怎么输出，但是，没怎么详细说明怎么使用训练结果，现在具体说明。下面是两个模型文件：</p>
<p>5.1              5.2</p>
<p> 图5.1 两类模型文件                                 图5.2 三类模型文件</p>
<p>从图5.1和5.2比较可以看出，两类只存在一个分类器，因此每个支持向量对应的系数α(也就是SV的第一排)，也只有 1个（当然，截距rho也只有一个）。这种情况最简单，只要把相应的支持向量和α的值带入方程：</p>
<p>5.3                                (5.1)</p>
<p>找到为0的解，就是分界点了。（式中，有些文献是+b，libSVM采用的是-b）</p>
<p> 对于三类或多类时，情况就比较复杂。我们原来讨论过，对于类数k&gt;2的情况，分类器个数为k×(k-1)/2个，那么对应的b值（也就是rho）应该也是k×(k-1)/2个。那么每个支持向量对应的系数α是多少呢？是k-1个，因为每个支持向量（sv）与其他每个类都有一个系数相对应。当然，和有的类对应时可能不是标准支持向量(0&lt;alpha[i]&lt;C)，但是至少和其中一个类对应是标准的。我们先看一下图5.2的SV的数据结构：</p>
<p>各nSV对应的αiyi</p>
<p>特征1</p>
<p>特征2</p>
<p>类0(label为-1)</p>
<p>前13个</p>
<p>类0 - V -类1</p>
<p>类0 - V -类2</p>
<p>1:0.297595</p>
<p>2:1.197805</p>
<p>0.4800095239454689</p>
<p>0.2016577869168293</p>
<p>类1(label为0)</p>
<p>中间9个</p>
<p>类1 - V -类0</p>
<p>类1 - V -类2</p>
<p>1:3.621706</p>
<p>2:1.263636</p>
<p>-0.6580578158072528</p>
<p>0.7036762846823739</p>
<p>类2(label为1)</p>
<p>后8个</p>
<p>类2 - V -类0</p>
<p>类2 - V -类1</p>
<p>1:8.296066</p>
<p>2:7.225341</p>
<p>-0.7056286598529473</p>
<p>-0.6494097661702236</p>
<pre><code>从表中，可以看出，每个支持向量(SV)都有相应的k-1（这里的k为3）个α，后面就是向量的数据。因此，输出分界线时，只要认清系数的位置就可以了。如要输出类0和类2之间的分界线，就要带入类0的第二列和类2的第1列中的α。
</code></pre><p>   这里需要重点说明的是：文件输出的不是单纯的α，实际上是αiyi（这里的yi是在训练时的+1或-1，而不是原始样本的label），因此在带入5.1式时，不需要判断yi的值了。</p>
<pre><code>  了解了数据结构以后，就是求解方程。5.1式是个多元方程（这和x的维数有关，这里讨论的是2维的，因此是二元方程），而只有一个等式，因此要对其中一个参数做定常处理。先求出其中一个参数的范围，不妨设为x[0]（在绘图时相当于x坐标轴）x_max和x_min，然后分成100等分，对每一个节点处

  x[0]i = i×(x_max- x_min)/100+ x_min

  这样，x[0]就相当于固定了，然后代入5.1式求x[1]（也就是y）。这就转化成了一元方程，可以采用传统的数学解法，这里，我采用的是网络遍历法。也就是对x[1]也分成100分进行遍历，把节点处的x[1]：

   x[1]j = j×(y_max- y_min)/100+ y_min

 代入5.1式，看是否接近于0，如果接近0，说明此点是边界点，然后输出坐标就可以了。

                                             for(i = 0; i &lt; 100; i ++)

                                                    for(j = 0; j &lt; 100; j ++)

                                                    {

                                                           X[0] = x[0]i;

                                                           X[1] = x[1]j;

                                                         if(5.4)

                                                          cout &lt;&lt; X[0] &lt;&lt; “ “ &lt;&lt;  X[1] &lt;&lt;endl;

                                                    }

分界点坐标输出以后，就可以用matlab把分界线绘制出来了。
</code></pre><p>easy.py和grid.py的使用</p>
<p>我们在“LibSVM学习（一）”中，讲到libSVM有一个tools文件夹，里面包含有四个python文件，是用来对参数优选的。其中，常用到的是easy.py和grid.py两个文件。其实，网上也有相应的说明，但很不系统，下面结合本人的经验，对使用方法做个说明。</p>
<pre><code>这两个文件都要用python（可以在http://www.python.org上下载到，需要安装）和绘图工具gnuplot（可以在ftp://ftp.gnuplot.info/pub/gnuplot/上下载，不需要安装）。假设python安装在d:/libsvm/tools/python26下，而gnuplot解压到d:/libsvm/tools/gnuplot，libsvm放在了d:/libsvm/program中（这时easy.py和grid.py文件的目录为d:/libsvm/program/tools）。另外，需要注意的是版本，我的是python 2.6、gnuplot 4.2 和libsvm 2.89，操作系统是WINXP。
</code></pre><ol>
<li><p>grid.py使用方法</p>
<pre><code>文件grid.py是对C-SVC的参数c和γ做优选的，原理也是网格遍历，假设我们要对目录d:/libsvm/program/tools下的样本文件heart_scale做优选，其具体用法为：
</code></pre></li>
</ol>
<pre><code> 第一步：打开d:/libsvm/program下的tools文件夹，找到grid.py文件。用python打开（不能双击，而要右键选择“Edit with IDLE”），修改svmtrain_exe和gnuplot_exe的路径。

                        svmtrain_exe = r&quot;D:/libSVM/program/svm-train.exe&quot;

                        gnuplot_exe = r&quot;D:/libSVM/gnuplot/pgnuplot.exe&quot;

 （这里面有一个是对非win32的，可以不用改，只改# example for windows下的就可以了）

第二步：运行cmd，进入dos环境，定位到d:/libsvm/program/tools文件夹，这里是放置grid.py的地方。怎么定位可以参看第一节。

第三步：输入以下命令：

                                    d:/libsvm/python26/python grid.py heart_scale

 你就会看到dos窗口中飞速乱串的[local]数据，以及一个gnuplot的动态绘图窗口。大约过10秒钟，就会停止。Dos窗口中的[local]数据时局部最优值，这个不用管，直接看最后一行：

                                    2048.0 0.0001220703125 84.0741

 其意义表示：C = 2048.0；γ=0.0001220703125（γ是哪个参数？参看LibSVM学习（三）中svmtrain的参数说明）；交叉验证精度CV Rate = 84.0741%，这就是最优结果。

第四步：打开目录d:/libsvm/program/tools，我们可以看到新生成了两个文件：heart_scale.out和heart_scale.png，第一个文件就是搜索过程中的[local]和最优数据，第二文件就是gnuplot图像。

 现在，grid.py已经运行完了，你可以把最优参数输入到svmtrain中进行训练了。当然了，你在当中某一步很可能出现问题，不过不要紧，我也不是一下子成功的，摸索了半天才成功。下面就需要注意的问题说明一下：

  1）grid.py和svm-train的版本要统一，也就是说你不能用2.6的grid.py去调用2.89的svm-train。

  2）你的目录中如果有空格，比如d:/program files/ libsvm/...，那么无论是在第一步还是第二步，请把目录改成d:/progra~1/ libsvm/...

  3) 第三步的命令问题。首先要看你定位到哪个目录，那么其下的文件就不需要带路径，否则就要带。像我们上面的命令，我当前的目录是d:/libsvm/program/tools，那么其下的easy.py和heart_scale文件就不需要加路径，而python.exe是在d:/libsvm/python26/下，因此不在当前目录下，所以要加路径。比如，当我首先用dos定位到d:/libsvm/python26时，其命令就可以改成：

               python  d:/libsvm/program/tools/grid.py  d:/libsvm/program/tools/heart_scale

 总起来说，命令为python 目标文件 样本文件，其原则是要让系统找得到文件。假如系统提示你“不是内部或外部命令”，说明你python的路径错误，而如果是‘not found file’的提示，很可能是其他两个文件路径错误。

  4）假如，你仍旧出现问题，那么请换一下python或者gnuplot的版本，目前python最新版本是3.1，但是好像会出问题，老一点的版本2.4或2.5的兼容性会更好。
</code></pre><ol start="2">
<li><p>easy.py使用方法</p>
<p> 文件easy.py对样本文件做了“一条龙服务”，从参数优选，到文件预测。因此，其对grid.py、svm-train、svm-scale和svm-predict都进行了调用（当然还有必须的python和gnuplot）。因此，运行easy.py需要保证这些文件的路径都要正确。当然还需要样本文件和预测文件，这里样本文件还是用heart_scale，预测文件我们复制一份然后改名heart_test，下面说一下使用方法：</p>
<p> 第一步：打开easy.py，修改# example for windows下的几个路径： </p>
</li>
</ol>
<p>6.1</p>
<p>   第二步：运行cmd，进入dos环境，定位到放置easy.py的目录d:/libsvm/program/tools。</p>
<p>   第三步：输入命令：</p>
<pre><code>                d:/libsvm/python26/python easy.py heart_scale heat_test

       你就会看到一个gnuplot的动态绘图窗口。大约20s以后停止，dos窗口显示为：

                               Scaling training data...

                               Cross validation...

                               Best c=2048.0, g=0.0001220703125 CV rate=84.0741

                               Training...

                               Output model: heart_scale.model

                               Scaling testing data...

                               Testing...

                               Accuracy = 85.1852% (230/270) (classification)

                               Output prediction: heart_test.predict

这就是最终预测结果，可以看到第三行就是调用grid.py的结果。在d:/libsvm/program/tools下你会看到又多了7个文件，都是以前我们碰到的过程文件，都可以用记事本打开。
</code></pre><ol start="3">
<li><p>常见的问题解析：</p>
<p> 1）</p>
<pre><code>     Scaling training data...
       Cross validation...
       Traceback (most recent call last):
       File &quot;easy.py&quot;, line 61, in ?
       c,g,rate = map(float,last_line.split())
       ValueError: need more than 0 values to unpack

[解析] 说明你的grid.py运行出现错误，你可以参照第一部分“grid.py使用方法”运行一下就会发现问题。另外，有的说是相对路径的问题，建议找到easy.py的以下部分：

cmd = &quot;%s -svmtrain %s -gnuplot %s %s&quot; % (grid_py, svmtrain_exe, gnuplot_exe, scaled_file)
</code></pre><p>改成</p>
<pre><code>cmd = &quot;%s %s -svmtrain %s -gnuplot %s %s&quot; % (python_path, grid_py, svmtrain_exe, gnuplot_exe, scaled_file)
</code></pre><p>  2）</p>
<pre><code>     Traceback (most recent call last)
       File &quot;grid.py&quot;, line 349, in ?
       main()
       File &quot;grid.py&quot;, line 344, in main
       redraw(db)
       File &quot;grid.py&quot;, line 132, in redraw
       gnuplot.write(&quot;set term windows/n&quot;)
       IOError [Errno 22] Invalid argument
[解析]说明你的gnuplot.exe在调用过程中出现问题，要么是你的路径不对，要么是你的版本不对，请检查。
</code></pre><p> 3）</p>
<pre><code>     Traceback (most recent call last):
       File &quot;C:/Python24/lib/threading.py&quot;, line 442, in __bootstrap 
       self.run() 
       File &quot;c:/libsvm/tools/gridregression.py&quot;, line 212, in run 
       self.job_queue.put((cexp,gexp,pexp)) 
       File &quot;C:/Python24/lib/Queue.py&quot;, line 88, in put 
       self._put(item) 
       File &quot;c:/libsvm/tools/gridregression.py&quot;, line 268, in _put 
       self.queue.insert(0,item) 
       AttributeError: &apos;collections.deque&apos; object has no attribute &apos;insert

[解析] 很显然，你调用的是gridregression.py，其是用来做回归用的。如果你调用easy.py也出现这种问题按照原作者的说法，这里是因为你的python调用出现错误，很可能是版本不对，如果是2.4的版本，请把easy.py中的
</code></pre><p>   self.queue.insert(0,item)<br>改成<br>   if sys.hexversion &gt;= 0x020400A1:</p>
<pre><code>       self.queue.appendleft(item)
else
       self.queue.insert(0,item)
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhang-hongbin.github.io/2017/03/10/SVM入门（十）将SVM用于多类分类（转载）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Hongbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo590vn4k.bkt.clouddn.com/111.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHB-CSDN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/SVM入门（十）将SVM用于多类分类（转载）/" itemprop="url">
                  SVM入门（十）将SVM用于多类分类（转载）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T13:36:46+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从 SVM的那几张图可以看出来，SVM是一种典型的两类分类器，即它只回答属于正类还是负类的问题。而现实中要解决的问题，往往是多类的问题（少部分例外，例如垃圾邮件过滤，就只需要确定“是”还是“不是”垃圾邮件），比如文本分类，比如数字识别。如何由两类分类器得到多类分类器，就是一个值得研究的问题。</p>
<p>还以文本分类为例，现成的方法有很多，其中一种一劳永逸的方法，就是真的一次性考虑所有样本，并求解一个多目标函数的优化问题，一次性得到多个分类面，就像下图这样：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMSVM_CBFA/clip_image001_thumb.jpg" alt=""></p>
<p>多个超平面把空间划分为多个区域，每个区域对应一个类别，给一篇文章，看它落在哪个区域就知道了它的分类。</p>
<p>看起来很美对不对？只可惜这种算法还基本停留在纸面上，因为一次性求解的方法计算量实在太大，大到无法实用的地步。</p>
<p>稍稍退一步，我们就会想到所谓“一类对其余”的方法，就是每次仍然解一个两类分类的问题。比如我们有5个类别，第一次就把类别1的样本定为正样本，其余2，3，4，5的样本合起来定为负样本，这样得到一个两类分类器，它能够指出一篇文章是还是不是第1类的；第二次我们把类别2 的样本定为正样本，把1，3，4，5的样本合起来定为负样本，得到一个分类器，如此下去，我们可以得到5个这样的两类分类器（总是和类别的数目一致）。到了有文章需要分类的时候，我们就拿着这篇文章挨个分类器的问：是属于你的么？是属于你的么？哪个分类器点头说是了，文章的类别就确定了。这种方法的好处是每个优化问题的规模比较小，而且分类的时候速度很快（只需要调用5个分类器就知道了结果）。但有时也会出现两种很尴尬的情况，例如拿一篇文章问了一圈，每一个分类器都说它是属于它那一类的，或者每一个分类器都说它不是它那一类的，前者叫分类重叠现象，后者叫不可分类现象。分类重叠倒还好办，随便选一个结果都不至于太离谱，或者看看这篇文章到各个超平面的距离，哪个远就判给哪个。不可分类现象就着实难办了，只能把它分给第6个类别了……更要命的是，本来各个类别的样本数目是差不多的，但“其余”的那一类样本数总是要数倍于正类（因为它是除正类以外其他类别的样本之和嘛），这就人为的造成了上一节所说的“数据集偏斜”问题。</p>
<p>因此我们还得再退一步，还是解两类分类问题，还是每次选一个类的样本作正类样本，而负类样本则变成只选一个类（称为“一对一单挑”的方法，哦，不对，没有单挑，就是“一对一”的方法，呵呵），这就避免了偏斜。因此过程就是算出这样一些分类器，第一个只回答“是第1类还是第2类”，第二个只回答“是第1类还是第3类”，第三个只回答“是第1类还是第4类”，如此下去，你也可以马上得出，这样的分类器应该有5 X 4/2=10个（通式是，如果有k个类别，则总的两类分类器数目为k(k-1)/2）。虽然分类器的数目多了，但是在训练阶段（也就是算出这些分类器的分类平面时）所用的总时间却比“一类对其余”方法少很多，在真正用来分类的时候，把一篇文章扔给所有分类器，第一个分类器会投票说它是“1”或者“2”，第二个会说它是“1”或者“3”，让每一个都投上自己的一票，最后统计票数，如果类别“1”得票最多，就判这篇文章属于第1类。这种方法显然也会有分类重叠的现象，但不会有不可分类现象，因为总不可能所有类别的票数都是0。看起来够好么？其实不然，想想分类一篇文章，我们调用了多少个分类器？10个，这还是类别数为5的时候，类别数如果是1000，要调用的分类器数目会上升至约500,000个（类别数的平方量级）。这如何是好？</p>
<p>看来我们必须再退一步，在分类的时候下功夫，我们还是像一对一方法那样来训练，只是在对一篇文章进行分类之前，我们先按照下面图的样子来组织分类器（如你所见，这是一个有向无环图，因此这种方法也叫做DAG SVM）</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMSVM_CBFA/clip_image002_thumb.gif" alt=""></p>
<p>这样在分类时,我们就可以先问分类器“1对5”（意思是它能够回答“是第1类还是第5类”），如果它回答5，我们就往左走，再问“2对5”这个分类器，如果它还说是“5”，我们就继续往左走，这样一直问下去，就可以得到分类结果。好处在哪？我们其实只调用了4个分类器（如果类别数是k，则只调用k-1个），分类速度飞快，且没有分类重叠和不可分类现象！缺点在哪？假如最一开始的分类器回答错误（明明是类别1的文章，它说成了5），那么后面的分类器是无论如何也无法纠正它的错误的（因为后面的分类器压根没有出现“1”这个类别标签），其实对下面每一层的分类器都存在这种错误向下累积的现象。。</p>
<p>不过不要被DAG方法的错误累积吓倒，错误累积在一对其余和一对一方法中也都存在，DAG方法好于它们的地方就在于，累积的上限，不管是大是小，总是有定论的，有理论证明。而一对其余和一对一方法中，尽管每一个两类分类器的泛化误差限是知道的，但是合起来做多类分类的时候，误差上界是多少，没人知道，这意味着准确率低到0也是有可能的，这多让人郁闷。</p>
<p>而且现在DAG方法根节点的选取（也就是如何选第一个参与分类的分类器），也有一些方法可以改善整体效果，我们总希望根节点少犯错误为好，因此参与第一次分类的两个类别，最好是差别特别特别大，大到以至于不太可能把他们分错；或者我们就总取在两类分类中正确率最高的那个分类器作根节点，或者我们让两类分类器在分类的时候，不光输出类别的标签，还输出一个类似“置信度”的东东，当它对自己的结果不太自信的时候，我们就不光按照它的输出走，把它旁边的那条路也走一走，等等。</p>
<p>大Tips：SVM的计算复杂度</p>
<p>使用SVM进行分类的时候，实际上是训练和分类两个完全不同的过程，因而讨论复杂度就不能一概而论，我们这里所说的主要是训练阶段的复杂度，即解那个二次规划问题的复杂度。对这个问题的解，基本上要划分为两大块，解析解和数值解。</p>
<p>解析解就是理论上的解，它的形式是表达式，因此它是精确的，一个问题只要有解（无解的问题还跟着掺和什么呀，哈哈），那它的解析解是一定存在的。当然存在是一回事，能够解出来，或者可以在可以承受的时间范围内解出来，就是另一回事了。对SVM来说，求得解析解的时间复杂度最坏可以达到O(Nsv3)，其中Nsv是支持向量的个数，而虽然没有固定的比例，但支持向量的个数多少也和训练集的大小有关。</p>
<p>数值解就是可以使用的解，是一个一个的数，往往都是近似解。求数值解的过程非常像穷举法，从一个数开始，试一试它当解效果怎样，不满足一定条件（叫做停机条件，就是满足这个以后就认为解足够精确了，不需要继续算下去了）就试下一个，当然下一个数不是乱选的，也有一定章法可循。有的算法，每次只尝试一个数，有的就尝试多个，而且找下一个数字（或下一组数）的方法也各不相同，停机条件也各不相同，最终得到的解精度也各不相同，可见对求数值解的复杂度的讨论不能脱开具体的算法。</p>
<p>一个具体的算法，Bunch-Kaufman训练算法，典型的时间复杂度在O(Nsv3+LNsv2+dLNsv)和O(dL2)之间，其中Nsv是支持向量的个数，L是训练集样本的个数，d是每个样本的维数（原始的维数，没有经过向高维空间映射之前的维数）。复杂度会有变化，是因为它不光跟输入问题的规模有关（不光和样本的数量，维数有关），也和问题最终的解有关（即支持向量有关），如果支持向量比较少，过程会快很多，如果支持向量很多，接近于样本的数量，就会产生O(dL2)这个十分糟糕的结果（给10，000个样本，每个样本1000维，基本就不用算了，算不出来，呵呵，而这种输入规模对文本分类来说太正常了）。</p>
<p>这样再回头看就会明白为什么一对一方法尽管要训练的两类分类器数量多，但总时间实际上比一对其余方法要少了，因为一对其余方法每次训练都考虑了所有样本（只是每次把不同的部分划分为正类或者负类而已），自然慢上很多。</p>
<p>注：转载自Jasper’s Java Jacal的博客<a href="http://www.blogjava.net/zhenandaci/archive/2009/03/26/262113.html" target="_blank" rel="noopener">http://www.blogjava.net/zhenandaci/archive/2009/03/26/262113.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhang-hongbin.github.io/2017/03/09/SVM入门（九）松弛变量（续）（转载）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Hongbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo590vn4k.bkt.clouddn.com/111.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHB-CSDN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/SVM入门（九）松弛变量（续）（转载）/" itemprop="url">
                  SVM入门（九）松弛变量（续）（转载）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T13:36:46+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接下来要说的东西其实不是松弛变量本身，但由于是为了使用松弛变量才引入的，因此放在这里也算合适，那就是惩罚因子C。回头看一眼引入了松弛变量以后的优化问题：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_11A27/clip_image002_thumb.gif" alt=""></p>
<p>注意其中C的位置，也可以回想一下C所起的作用（表征你有多么重视离群点，C越大越重视，越不想丢掉它们）。这个式子是以前做SVM的人写的，大家也就这么用，但没有任何规定说必须对所有的松弛变量都使用同一个惩罚因子，我们完全可以给每一个离群点都使用不同的C，这时就意味着你对每个样本的重视程度都不一样，有些样本丢了也就丢了，错了也就错了，这些就给一个比较小的C；而有些样本很重要，决不能分类错误（比如中央下达的文件啥的，笑），就给一个很大的C。</p>
<p>当然实际使用的时候并没有这么极端，但一种很常用的变形可以用来解决分类问题中样本的“偏斜”问题。</p>
<p>先来说说样本的偏斜问题，也叫数据集偏斜（unbalanced），它指的是参与分类的两个类别（也可以指多个类别）样本数量差异很大。比如说正类有10，000个样本，而负类只给了100个，这会引起的问题显而易见，可以看看下面的图：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_11A27/image_thumb.png" alt=""></p>
<p>方形的点是负类。H，H1，H2是根据给的样本算出来的分类面，由于负类的样本很少很少，所以有一些本来是负类的样本点没有提供，比如图中两个灰色的方形点，如果这两个点有提供的话，那算出来的分类面应该是H’，H2’和H1，他们显然和之前的结果有出入，实际上负类给的样本点越多，就越容易出现在灰色点附近的点，我们算出的结果也就越接近于真实的分类面。但现在由于偏斜的现象存在，使得数量多的正类可以把分类面向负类的方向“推”，因而影响了结果的准确性。</p>
<p>对付数据集偏斜问题的方法之一就是在惩罚因子上作文章，想必大家也猜到了，那就是给样本数量少的负类更大的惩罚因子，表示我们重视这部分样本（本来数量就少，再抛弃一些，那人家负类还活不活了），因此我们的目标函数中因松弛变量而损失的部分就变成了：</p>
<p> <img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_11A27/clip_image002%5B5%5D_thumb.gif" alt=""></p>
<p>其中i=1…p都是正样本，j=p+1…p+q都是负样本。libSVM这个算法包在解决偏斜问题的时候用的就是这种方法。</p>
<p>那C+和C–怎么确定呢？它们的大小是试出来的（参数调优），但是他们的比例可以有些方法来确定。咱们先假定说C+是5这么大，那确定C–的一个很直观的方法就是使用两类样本数的比来算，对应到刚才举的例子，C–就可以定为500这么大（因为10，000：100=100：1嘛）。</p>
<p>但是这样并不够好，回看刚才的图，你会发现正类之所以可以“欺负”负类，其实并不是因为负类样本少，真实的原因是负类的样本分布的不够广（没扩充到负类本应该有的区域）。说一个具体点的例子，现在想给政治类和体育类的文章做分类，政治类文章很多，而体育类只提供了几篇关于篮球的文章，这时分类会明显偏向于政治类，如果要给体育类文章增加样本，但增加的样本仍然全都是关于篮球的（也就是说，没有足球，排球，赛车，游泳等等），那结果会怎样呢？虽然体育类文章在数量上可以达到与政治类一样多，但过于集中了，结果仍会偏向于政治类！所以给C+和C–确定比例更好的方法应该是衡量他们分布的程度。比如可以算算他们在空间中占据了多大的体积，例如给负类找一个超球——就是高维空间里的球啦——它可以包含所有负类的样本，再给正类找一个，比比两个球的半径，就可以大致确定分布的情况。显然半径大的分布就比较广，就给小一点的惩罚因子。</p>
<p>但是这样还不够好，因为有的类别样本确实很集中，这不是提供的样本数量多少的问题，这是类别本身的特征（就是某些话题涉及的面很窄，例如计算机类的文章就明显不如文化类的文章那么“天马行空”），这个时候即便超球的半径差异很大，也不应该赋予两个类别不同的惩罚因子。</p>
<p>看到这里读者一定疯了，因为说来说去，这岂不成了一个解决不了的问题？然而事实如此，完全的方法是没有的，根据需要，选择实现简单又合用的就好（例如libSVM就直接使用样本数量的比）。</p>
<p>注：转载自Jasper’s Java Jacal的博客<a href="http://www.blogjava.net/zhenandaci/archive/2009/03/17/260315.html" target="_blank" rel="noopener">http://www.blogjava.net/zhenandaci/archive/2009/03/17/260315.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhang-hongbin.github.io/2017/03/08/SVM入门（八）松弛变量（转载）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Hongbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo590vn4k.bkt.clouddn.com/111.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHB-CSDN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/SVM入门（八）松弛变量（转载）/" itemprop="url">
                  SVM入门（八）松弛变量（转载）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T13:36:46+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在我们已经把一个本来线性不可分的文本分类问题，通过映射到高维空间而变成了线性可分的。就像下图这样：</p>
<p> <img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/image_thumb.png" alt=""></p>
<p>圆形和方形的点各有成千上万个（毕竟，这就是我们训练集中文档的数量嘛，当然很大了）。现在想象我们有另一个训练集，只比原先这个训练集多了一篇文章，映射到高维空间以后（当然，也使用了相同的核函数），也就多了一个样本点，但是这个样本的位置是这样的：<br> <img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/image_thumb_1.png" alt=""></p>
<p>就是图中黄色那个点，它是方形的，因而它是负类的一个样本，这单独的一个样本，使得原本线性可分的问题变成了线性不可分的。这样类似的问题（仅有少数点线性不可分）叫做“近似线性可分”的问题。</p>
<p>以我们人类的常识来判断，说有一万个点都符合某种规律（因而线性可分），有一个点不符合，那这一个点是否就代表了分类规则中我们没有考虑到的方面呢（因而规则应该为它而做出修改）？</p>
<p>其实我们会觉得，更有可能的是，这个样本点压根就是错误，是噪声，是提供训练集的同学人工分类时一打瞌睡错放进去的。所以我们会简单的忽略这个样本点，仍然使用原来的分类器，其效果丝毫不受影响。</p>
<p>但这种对噪声的容错性是人的思维带来的，我们的程序可没有。由于我们原本的优化问题的表达式中，确实要考虑所有的样本点（不能忽略某一个，因为程序它怎么知道该忽略哪一个呢？），在此基础上寻找正负类之间的最大几何间隔，而几何间隔本身代表的是距离，是非负的，像上面这种有噪声的情况会使得整个问题无解。这种解法其实也叫做“硬间隔”分类法，因为他硬性的要求所有样本点都满足和分类平面间的距离必须大于某个值。</p>
<p>因此由上面的例子中也可以看出，硬间隔的分类法其结果容易受少数点的控制，这是很危险的（尽管有句话说真理总是掌握在少数人手中，但那不过是那一小撮人聊以自慰的词句罢了，咱还是得民主）。</p>
<p>但解决方法也很明显，就是仿照人的思路，允许一些点到分类平面的距离不满足原先的要求。由于不同的训练集各点的间距尺度不太一样，因此用间隔（而不是几何间隔）来衡量有利于我们表达形式的简洁。我们原先对样本点的要求是：</p>
<p> <img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002_thumb.gif" alt=""></p>
<p>意思是说离分类面最近的样本点函数间隔也要比1大。如果要引入容错性，就给1这个硬性的阈值加一个松弛变量，即允许</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002%5B5%5D_thumb.gif" alt=""></p>
<p>因为松弛变量是非负的，因此最终的结果是要求间隔可以比1小。但是当某些点出现这种间隔比1小的情况时（这些点也叫离群点），意味着我们放弃了对这些点的精确分类，而这对我们的分类器来说是种损失。但是放弃这些点也带来了好处，那就是使分类面不必向这些点的方向移动，因而可以得到更大的几何间隔（在低维空间看来，分类边界也更平滑）。显然我们必须权衡这种损失和好处。好处很明显，我们得到的分类间隔越大，好处就越多。回顾我们原始的硬间隔分类对应的优化问题：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002%5B7%5D_thumb.gif" alt=""></p>
<p>||w||2就是我们的目标函数（当然系数可有可无），希望它越小越好，因而损失就必然是一个能使之变大的量（能使它变小就不叫损失了，我们本来就希望目标函数值越小越好）。那如何来衡量损失，有两种常用的方式，有人喜欢用</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002%5B9%5D_thumb.gif" alt=""></p>
<p>而有人喜欢用</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002%5B11%5D_thumb.gif" alt=""></p>
<p>其中l都是样本的数目。两种方法没有大的区别。如果选择了第一种，得到的方法的就叫做二阶软间隔分类器，第二种就叫做一阶软间隔分类器。把损失加入到目标函数里的时候，就需要一个惩罚因子（cost，也就是libSVM的诸多参数中的C），原来的优化问题就变成了下面这样：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVM_D32/clip_image002%5B13%5D_thumb.gif" alt=""></p>
<p>这个式子有这么几点要注意：</p>
<p>一是并非所有的样本点都有一个松弛变量与其对应。实际上只有“离群点”才有，或者也可以这么看，所有没离群的点松弛变量都等于0（对负类来说，离群点就是在前面图中，跑到H2右侧的那些负样本点，对正类来说，就是跑到H1左侧的那些正样本点）。</p>
<p>二是松弛变量的值实际上标示出了对应的点到底离群有多远，值越大，点就越远。</p>
<p>三是惩罚因子C决定了你有多重视离群点带来的损失，显然当所有离群点的松弛变量的和一定时，你定的C越大，对目标函数的损失也越大，此时就暗示着你非常不愿意放弃这些离群点，最极端的情况是你把C定为无限大，这样只要稍有一个点离群，目标函数的值马上变成无限大，马上让问题变成无解，这就退化成了硬间隔问题。</p>
<p>四是惩罚因子C不是一个变量，整个优化问题在解的时候，C是一个你必须事先指定的值，指定这个值以后，解一下，得到一个分类器，然后用测试数据看看结果怎么样，如果不够好，换一个C的值，再解一次优化问题，得到另一个分类器，再看看效果，如此就是一个参数寻优的过程，但这和优化问题本身决不是一回事，优化问题在解的过程中，C一直是定值，要记住。</p>
<p>五是尽管加了松弛变量这么一说，但这个优化问题仍然是一个优化问题（汗，这不废话么），解它的过程比起原始的硬间隔问题来说，没有任何更加特殊的地方。</p>
<p>从大的方面说优化问题解的过程，就是先试着确定一下w，也就是确定了前面图中的三条直线，这时看看间隔有多大，又有多少点离群，把目标函数的值算一算，再换一组三条直线（你可以看到，分类的直线位置如果移动了，有些原来离群的点会变得不再离群，而有的本来不离群的点会变成离群点），再把目标函数的值算一算，如此往复（迭代），直到最终找到目标函数最小时的w。</p>
<p>啰嗦了这么多，读者一定可以马上自己总结出来，松弛变量也就是个解决线性不可分问题的方法罢了，但是回想一下，核函数的引入不也是为了解决线性不可分的问题么？为什么要为了一个问题使用两种方法呢？</p>
<p>其实两者还有微妙的不同。一般的过程应该是这样，还以文本分类为例。在原始的低维空间中，样本相当的不可分，无论你怎么找分类平面，总会有大量的离群点，此时用核函数向高维空间映射一下，虽然结果仍然是不可分的，但比原始空间里的要更加接近线性可分的状态（就是达到了近似线性可分的状态），此时再用松弛变量处理那些少数“冥顽不化”的离群点，就简单有效得多啦。</p>
<p>本节中的（式1）也确实是支持向量机最最常用的形式。至此一个比较完整的支持向量机框架就有了，简单说来，支持向量机就是使用了核函数的软间隔线性分类法。</p>
<p>下一节会说说松弛变量剩下的一点点东西，顺便搞个读者调查，看看大家还想侃侃SVM的哪些方面。</p>
<p>注：转载自Jasper’s Java Jacal的博客<a href="http://www.blogjava.net/zhenandaci/archive/2009/03/15/259786.html" target="_blank" rel="noopener">http://www.blogjava.net/zhenandaci/archive/2009/03/15/259786.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo590vn4k.bkt.clouddn.com/111.png"
               alt="Zhang Hongbin" />
          <p class="site-author-name" itemprop="name">Zhang Hongbin</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">88</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">85</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Hongbin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
